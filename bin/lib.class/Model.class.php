<?php

// Generated by Haxe 3.4.7
class Model {
	public function __construct($param = null) {
		if(!php_Boot::$skip_constructor) {
		$this->param = $param;
		$tmp = null;
		if($param !== null) {
			$tmp = $param->get("firstLoad") === "true";
		} else {
			$tmp = false;
		}
		if($tmp) {
			haxe_Log::trace("firstLoad", _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 493, "className" => "Model", "methodName" => "new")));
			$this->globals = _hx_anonymous(array());
			$this->globals->users = $this->query("SELECT full_name, user, active, user_group FROM vicidial_users");
		}
	}}
	public $data;
	public $db;
	public $globals;
	public $table;
	public $primary;
	public $num_rows;
	public $joinTable;
	public $param;
	public function count($q, $sb, $phValues) {
		$fields = $q->get("fields");
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "table:" . _hx_string_or_null($q->get("table")) . ":";
		$tmp2 = null;
		$v = $q->get("table");
		$tmp3 = null;
		$tmp4 = null;
		if($v !== null) {
			$tmp4 = !_hx_equal($v, 0);
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$tmp3 = !_hx_equal($v, "");
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			$tmp2 = $q->get("table");
		} else {
			$tmp2 = $this->table;
		}
		call_user_func_array($tmp, array(_hx_string_or_null($tmp1) . _hx_string_or_null($tmp2), _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 94, "className" => "Model", "methodName" => "count"))));
		$sb->add("SELECT COUNT(*) AS count");
		$qTable = null;
		$v1 = $q->get("table");
		$qTable1 = null;
		$qTable2 = null;
		if($v1 !== null) {
			$qTable2 = !_hx_equal($v1, 0);
		} else {
			$qTable2 = false;
		}
		if($qTable2) {
			$qTable1 = !_hx_equal($v1, "");
		} else {
			$qTable1 = false;
		}
		if($qTable1) {
			$qTable = $q->get("table");
		} else {
			$qTable = $this->table;
		}
		$joinCond = null;
		$v2 = $q->get("joincond");
		$joinCond1 = null;
		$joinCond2 = null;
		if($v2 !== null) {
			$joinCond2 = !_hx_equal($v2, 0);
		} else {
			$joinCond2 = false;
		}
		if($joinCond2) {
			$joinCond1 = !_hx_equal($v2, "");
		} else {
			$joinCond1 = false;
		}
		if($joinCond1) {
			$joinCond = $q->get("joincond");
		} else {
			$joinCond = null;
		}
		$joinTable = null;
		$v3 = $q->get("jointable");
		$joinTable1 = null;
		$joinTable2 = null;
		if($v3 !== null) {
			$joinTable2 = !_hx_equal($v3, 0);
		} else {
			$joinTable2 = false;
		}
		if($joinTable2) {
			$joinTable1 = !_hx_equal($v3, "");
		} else {
			$joinTable1 = false;
		}
		if($joinTable1) {
			$joinTable = $q->get("jointable");
		} else {
			$joinTable = null;
		}
		$sb->add(" FROM " . _hx_string_or_null(S::$my->real_escape_string($qTable)));
		$where = $q->get("where");
		if($where !== null) {
			$this->buildCond($where, $sb, $phValues, null);
		}
		$this1 = php_Lib::hashOfAssociativeArray(_hx_array_get($this->execute($sb->b, $phValues), 0));
		return $this1->get("count");
	}
	public function countJoin($q, $sb, $phValues) {
		$fields = $q->get("fields");
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "table:" . _hx_string_or_null($q->get("table")) . ":";
		$tmp2 = null;
		$v = $q->get("table");
		$tmp3 = null;
		$tmp4 = null;
		if($v !== null) {
			$tmp4 = !_hx_equal($v, 0);
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$tmp3 = !_hx_equal($v, "");
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			$tmp2 = $q->get("table");
		} else {
			$tmp2 = $this->table;
		}
		call_user_func_array($tmp, array(_hx_string_or_null($tmp1) . _hx_string_or_null($tmp2), _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 115, "className" => "Model", "methodName" => "countJoin"))));
		$sb->add("SELECT COUNT(*) AS count");
		$qTable = null;
		$v1 = $q->get("table");
		$qTable1 = null;
		$qTable2 = null;
		if($v1 !== null) {
			$qTable2 = !_hx_equal($v1, 0);
		} else {
			$qTable2 = false;
		}
		if($qTable2) {
			$qTable1 = !_hx_equal($v1, "");
		} else {
			$qTable1 = false;
		}
		if($qTable1) {
			$qTable = $q->get("table");
		} else {
			$qTable = $this->table;
		}
		$joinCond = null;
		$v2 = $q->get("joincond");
		$joinCond1 = null;
		$joinCond2 = null;
		if($v2 !== null) {
			$joinCond2 = !_hx_equal($v2, 0);
		} else {
			$joinCond2 = false;
		}
		if($joinCond2) {
			$joinCond1 = !_hx_equal($v2, "");
		} else {
			$joinCond1 = false;
		}
		if($joinCond1) {
			$joinCond = $q->get("joincond");
		} else {
			$joinCond = null;
		}
		$tmp5 = null;
		$v3 = $q->get("jointable");
		$tmp6 = null;
		$tmp7 = null;
		if($v3 !== null) {
			$tmp7 = !_hx_equal($v3, 0);
		} else {
			$tmp7 = false;
		}
		if($tmp7) {
			$tmp6 = !_hx_equal($v3, "");
		} else {
			$tmp6 = false;
		}
		if($tmp6) {
			$tmp5 = $q->get("jointable");
		} else {
			$tmp5 = null;
		}
		$this->joinTable = $tmp5;
		$filterTables = "";
		$v4 = $q->get("filter");
		$tmp8 = null;
		$tmp9 = null;
		if($v4 !== null) {
			$tmp9 = !_hx_equal($v4, 0);
		} else {
			$tmp9 = false;
		}
		if($tmp9) {
			$tmp8 = !_hx_equal($v4, "");
		} else {
			$tmp8 = false;
		}
		if($tmp8) {
			$filterTables = _hx_explode(",", $q->get("filter_tables"))->map(array(new _hx_lambda(array(), "Model_0"), 'execute'))->join(",");
			$sb->add(" FROM " . _hx_string_or_null($filterTables) . "," . _hx_string_or_null(S::$my->real_escape_string($qTable)));
		} else {
			$sb->add(" FROM " . _hx_string_or_null(S::$my->real_escape_string($qTable)));
		}
		if($this->joinTable !== null) {
			$sb->add(" INNER JOIN " . _hx_string_or_null($this->joinTable));
		}
		if($joinCond !== null) {
			$sb->add(" ON " . _hx_string_or_null($joinCond));
		}
		$where = $q->get("where");
		if($where !== null) {
			$this->buildCond($where, $sb, $phValues, null);
		}
		$v5 = $q->get("filter");
		$tmp10 = null;
		$tmp11 = null;
		if($v5 !== null) {
			$tmp11 = !_hx_equal($v5, 0);
		} else {
			$tmp11 = false;
		}
		if($tmp11) {
			$tmp10 = !_hx_equal($v5, "");
		} else {
			$tmp10 = false;
		}
		if($tmp10) {
			$this->buildCond(_hx_explode(",", $q->get("filter"))->map(array(new _hx_lambda(array(), "Model_1"), 'execute'))->join(","), $sb, $phValues, false);
			if($this->joinTable === "vicidial_users") {
				$sb->add(" " . _hx_string_or_null(_hx_explode(",", $filterTables)->map(array(new _hx_lambda(array(), "Model_2"), 'execute'))->join(" ")));
			} else {
				$sb->add(" " . _hx_string_or_null(_hx_explode(",", $filterTables)->map(array(new _hx_lambda(array(), "Model_3"), 'execute'))->join(" ")));
			}
		}
		$this1 = php_Lib::hashOfAssociativeArray(_hx_array_get($this->execute($sb->b, $phValues), 0));
		return $this1->get("count");
	}
	public function doJoin($q, $sb, $phValues) {
		$fields = $q->get("fields");
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "table:" . _hx_string_or_null($q->get("table")) . ":";
		$tmp2 = null;
		$v = $q->get("table");
		$tmp3 = null;
		$tmp4 = null;
		if($v !== null) {
			$tmp4 = !_hx_equal($v, 0);
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$tmp3 = !_hx_equal($v, "");
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			$tmp2 = $q->get("table");
		} else {
			$tmp2 = $this->table;
		}
		call_user_func_array($tmp, array(_hx_string_or_null($tmp1) . _hx_string_or_null($tmp2), _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 157, "className" => "Model", "methodName" => "doJoin"))));
		$tmp5 = null;
		if($fields !== null) {
			$tmp5 = $this->fieldFormat(_hx_explode(",", $fields)->map(array(new _hx_lambda(array(), "Model_4"), 'execute'))->join(","));
		} else {
			$tmp5 = "*";
		}
		$sb->add("SELECT " . _hx_string_or_null($tmp5));
		$qTable = null;
		$v1 = $q->get("table");
		$qTable1 = null;
		$qTable2 = null;
		if($v1 !== null) {
			$qTable2 = !_hx_equal($v1, 0);
		} else {
			$qTable2 = false;
		}
		if($qTable2) {
			$qTable1 = !_hx_equal($v1, "");
		} else {
			$qTable1 = false;
		}
		if($qTable1) {
			$qTable = $q->get("table");
		} else {
			$qTable = $this->table;
		}
		$joinCond = null;
		$v2 = $q->get("joincond");
		$joinCond1 = null;
		$joinCond2 = null;
		if($v2 !== null) {
			$joinCond2 = !_hx_equal($v2, 0);
		} else {
			$joinCond2 = false;
		}
		if($joinCond2) {
			$joinCond1 = !_hx_equal($v2, "");
		} else {
			$joinCond1 = false;
		}
		if($joinCond1) {
			$joinCond = $q->get("joincond");
		} else {
			$joinCond = null;
		}
		$joinTable = null;
		$v3 = $q->get("jointable");
		$joinTable1 = null;
		$joinTable2 = null;
		if($v3 !== null) {
			$joinTable2 = !_hx_equal($v3, 0);
		} else {
			$joinTable2 = false;
		}
		if($joinTable2) {
			$joinTable1 = !_hx_equal($v3, "");
		} else {
			$joinTable1 = false;
		}
		if($joinTable1) {
			$joinTable = $q->get("jointable");
		} else {
			$joinTable = null;
		}
		$filterTables = "";
		$v4 = $q->get("filter");
		$tmp6 = null;
		$tmp7 = null;
		if($v4 !== null) {
			$tmp7 = !_hx_equal($v4, 0);
		} else {
			$tmp7 = false;
		}
		if($tmp7) {
			$tmp6 = !_hx_equal($v4, "");
		} else {
			$tmp6 = false;
		}
		if($tmp6) {
			$filterTables = _hx_explode(",", $q->get("filter_tables"))->map(array(new _hx_lambda(array(), "Model_5"), 'execute'))->join(",");
			$sb->add(" FROM " . _hx_string_or_null($filterTables) . "," . _hx_string_or_null(S::$my->real_escape_string($qTable)));
		} else {
			$sb->add(" FROM " . _hx_string_or_null(S::$my->real_escape_string($qTable)));
		}
		if($joinTable !== null) {
			$sb->add(" INNER JOIN " . _hx_string_or_null($joinTable));
		}
		if($joinCond !== null) {
			$sb->add(" ON " . _hx_string_or_null($joinCond));
		}
		$where = $q->get("where");
		if($where !== null) {
			$this->buildCond($where, $sb, $phValues, null);
		}
		$v5 = $q->get("filter");
		$tmp8 = null;
		$tmp9 = null;
		if($v5 !== null) {
			$tmp9 = !_hx_equal($v5, 0);
		} else {
			$tmp9 = false;
		}
		if($tmp9) {
			$tmp8 = !_hx_equal($v5, "");
		} else {
			$tmp8 = false;
		}
		if($tmp8) {
			$this->buildCond(_hx_explode(",", $q->get("filter"))->map(array(new _hx_lambda(array(), "Model_6"), 'execute'))->join(","), $sb, $phValues, false);
			if($joinTable === "vicidial_users") {
				$sb->add(" " . _hx_string_or_null(_hx_explode(",", $filterTables)->map(array(new _hx_lambda(array(), "Model_7"), 'execute'))->join(" ")));
			} else {
				$sb->add(" " . _hx_string_or_null(_hx_explode(",", $filterTables)->map(array(new _hx_lambda(array(), "Model_8"), 'execute'))->join(" ")));
			}
		}
		$groupParam = $q->get("group");
		if($groupParam !== null) {
			$this->buildGroup($groupParam, $sb);
		}
		$order = $q->get("order");
		if($order !== null) {
			$this->buildOrder($order, $sb);
		}
		$limit = $q->get("limit");
		$tmp10 = null;
		if($limit === null) {
			$tmp10 = "15";
		} else {
			$tmp10 = $limit;
		}
		$this->buildLimit($tmp10, $sb);
		return $this->execute($sb->b, $phValues);
	}
	public function doSelect($q, $sb, $phValues) {
		$fields = $q->get("fields");
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "table:" . Std::string($q->get("table")) . ":";
		$tmp2 = null;
		$v = $q->get("table");
		$tmp3 = null;
		$tmp4 = null;
		if($v !== null) {
			$tmp4 = !_hx_equal($v, 0);
		} else {
			$tmp4 = false;
		}
		if($tmp4) {
			$tmp3 = !_hx_equal($v, "");
		} else {
			$tmp3 = false;
		}
		if($tmp3) {
			$tmp2 = $q->get("table");
		} else {
			$tmp2 = $this->table;
		}
		$tmp5 = _hx_string_or_null($tmp1) . Std::string($tmp2);
		call_user_func_array($tmp, array($tmp5, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 208, "className" => "Model", "methodName" => "doSelect"))));
		$tmp6 = null;
		if($fields !== null) {
			$tmp6 = $this->fieldFormat($fields);
		} else {
			$tmp6 = "*";
		}
		$sb->add("SELECT " . _hx_string_or_null($tmp6));
		$qTable = null;
		$v1 = $q->get("table");
		$qTable1 = null;
		$qTable2 = null;
		if($v1 !== null) {
			$qTable2 = !_hx_equal($v1, 0);
		} else {
			$qTable2 = false;
		}
		if($qTable2) {
			$qTable1 = !_hx_equal($v1, "");
		} else {
			$qTable1 = false;
		}
		if($qTable1) {
			$qTable = $q->get("table");
		} else {
			$qTable = $this->table;
		}
		$sb->add(" FROM " . _hx_string_or_null(S::$my->real_escape_string($qTable)));
		$where = $q->get("where");
		if($where !== null) {
			$this->buildCond($where, $sb, $phValues, null);
		}
		$groupParam = $q->get("group");
		if($groupParam !== null) {
			$this->buildGroup($groupParam, $sb);
		}
		$order = $q->get("order");
		if($order !== null) {
			$this->buildOrder($order, $sb);
		}
		$limit = $q->get("limit");
		$tmp7 = null;
		if($limit === null) {
			$tmp7 = "15";
		} else {
			$tmp7 = $limit;
		}
		$this->buildLimit($tmp7, $sb);
		return $this->execute($sb->b, $phValues);
	}
	public function fieldFormat($fields) {
		$fieldsWithFormat = new _hx_array(array());
		$sF = _hx_explode(",", $fields);
		$dbQueryFormats = php_Lib::hashOfAssociativeArray(php_Lib::associativeArrayOfObject(S::$conf->get("dbQueryFormats")));
		haxe_Log::trace($dbQueryFormats, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 236, "className" => "Model", "methodName" => "fieldFormat")));
		$qKeys = new _hx_array(array());
		$it = $dbQueryFormats->keys();
		while($it->hasNext()) {
			$qKeys->push($it->next());
		}
		{
			$_g = 0;
			while($_g < $sF->length) {
				$f = $sF[$_g];
				$_g = $_g + 1;
				if(Lambda::has($qKeys, $f)) {
					$format = $dbQueryFormats->get($f);
					if($format[0] === "ALIAS") {
						$tmp = _hx_string_or_null(S::$my->real_escape_string($f)) . " AS ";
						$fieldsWithFormat->push(_hx_string_or_null($tmp) . _hx_string_or_null($format[1]));
						unset($tmp);
					} else {
						$tmp1 = _hx_string_or_null($format[0]) . "(";
						$tmp2 = _hx_string_or_null($tmp1) . _hx_string_or_null(S::$my->real_escape_string($f)) . ", \"";
						$fieldsWithFormat->push(_hx_string_or_null($tmp2) . _hx_string_or_null($format[1]) . "\") AS `" . _hx_string_or_null($f) . "`");
						unset($tmp2,$tmp1);
					}
					unset($format);
				} else {
					$fieldsWithFormat->push(S::$my->real_escape_string($f));
				}
				unset($f);
			}
		}
		return $fieldsWithFormat->join(",");
	}
	public function find($param) {
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$count = $this->countJoin($param, $sb, $phValues);
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "count:" . _hx_string_rec($count, "") . " page:" . _hx_string_or_null($param->get("page")) . ": ";
		$tmp2 = null;
		if($param->exists("page")) {
			$tmp2 = "Y";
		} else {
			$tmp2 = "N";
		}
		call_user_func_array($tmp, array(_hx_string_or_null($tmp1) . _hx_string_or_null($tmp2), _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 272, "className" => "Model", "methodName" => "find"))));
		$tmp3 = null;
		if($param->exists("page")) {
			$tmp3 = Std::parseInt($param->get("page"));
		} else {
			$tmp3 = 1;
		}
		$this->data = _hx_anonymous(array("count" => $count, "page" => $tmp3, "rows" => $this->doSelect($param, $sb, $phValues)));
		return $this->json_encode();
	}
	public function execute($sql, $phValues = null) {
		haxe_Log::trace($sql, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 284, "className" => "Model", "methodName" => "execute")));
		$stmt = S::$my->stmt_init();
		$success = $stmt->prepare($sql);
		haxe_Log::trace($success, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 288, "className" => "Model", "methodName" => "execute")));
		if(!$success) {
			haxe_Log::trace($stmt->error, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 291, "className" => "Model", "methodName" => "execute")));
			return null;
		}
		$bindTypes = "";
		$values2bind = null;
		$dbFieldTypes = php_Lib::hashOfAssociativeArray(php_Lib::associativeArrayOfObject(S::$conf->get("dbFieldTypes")));
		$qObj = _hx_anonymous(array());
		$i = 0;
		{
			$_g = 0;
			while($_g < $phValues->length) {
				$ph = $phValues[$_g];
				$_g = $_g + 1;
				$type = $dbFieldTypes->get($ph[0]);
				$bindTypes1 = null;
				$bindTypes2 = null;
				$bindTypes3 = null;
				if($type !== null) {
					$bindTypes3 = $type !== 0;
				} else {
					$bindTypes3 = false;
				}
				if($bindTypes3) {
					$bindTypes2 = $type !== "";
				} else {
					$bindTypes2 = false;
				}
				if($bindTypes2) {
					$bindTypes1 = $type;
				} else {
					$bindTypes1 = "s";
				}
				$bindTypes = _hx_string_or_null($bindTypes) . _hx_string_or_null($bindTypes1);
				$i = $i + 1;
				$values2bind[$i - 1] = $ph[1];
				unset($type,$ph,$bindTypes3,$bindTypes2,$bindTypes1);
			}
		}
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = Std::string($values2bind);
		call_user_func_array($tmp, array($tmp1, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 308, "className" => "Model", "methodName" => "execute"))));
		if($phValues->length > 0) {
			$success = myBindParam($stmt, $values2bind, $bindTypes);
			$tmp2 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp3 = "success:" . Std::string($success);
			call_user_func_array($tmp2, array($tmp3, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 312, "className" => "Model", "methodName" => "execute"))));
			if($success) {
				$data = null;
				$success = $stmt->execute();
				if(!$success) {
					haxe_Log::trace($stmt->error, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 320, "className" => "Model", "methodName" => "execute")));
					return null;
				}
				$result = $stmt->get_result();
				if($result) {
					$this->num_rows = _hx_deref((_hx_cast($result, _hx_qtype("mysqli_result"))))->num_rows;
					$data = _hx_deref((_hx_cast($result, _hx_qtype("mysqli_result"))))->fetch_all(1);
				}
				return $data;
			}
		} else {
			$data1 = null;
			$success = $stmt->execute();
			if(!$success) {
				haxe_Log::trace($stmt->error, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 338, "className" => "Model", "methodName" => "execute")));
				return array("ERROR", $stmt->error);
			}
			$result1 = $stmt->get_result();
			if($result1) {
				$res = _hx_cast($result1, _hx_qtype("mysqli_result"));
				$this->num_rows = $res->num_rows;
				$data1 = $res->fetch_all(1);
			}
			return $data1;
		}
		return array("ERROR", $stmt->error);
	}
	public function query($sql) {
		haxe_Log::trace($sql, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 356, "className" => "Model", "methodName" => "query")));
		$ok = S::$my->real_query($sql);
		$tmp = null;
		if($ok) {
			$tmp = S::$my->field_count > 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$res = S::$my->store_result();
			haxe_Log::trace($res, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 363, "className" => "Model", "methodName" => "query")));
			$data = $res->fetch_all(1);
			$res->free();
			return $data;
		} else {
			$tmp1 = null;
			if($ok) {
				$tmp1 = "OK";
			} else {
				$tmp1 = "NOTOK" . _hx_string_or_null(S::$my->error);
			}
			haxe_Log::trace($tmp1, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 369, "className" => "Model", "methodName" => "query")));
		}
		if(S::$my->connect_error !== null) {
			haxe_Log::trace(S::$my->connect_error, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 371, "className" => "Model", "methodName" => "query")));
		}
		return null;
	}
	public function buildCond($whereParam, $sob, $phValues, $first = null) {
		if($first === null) {
			$first = true;
		}
		$sb = new StringBuf();
		$where = _hx_explode(",", $whereParam);
		if($where->length === 0) {
			return false;
		}
		{
			$_g = 0;
			while($_g < $where->length) {
				$w = $where[$_g];
				$_g = $_g + 1;
				$wData = _hx_string_call($w, "split", array("|"));
				$values = $wData->slice(2, null);
				$filter_tables = null;
				$tmp = null;
				$tmp1 = null;
				$v = $this->param;
				$tmp2 = null;
				$tmp3 = null;
				if($v !== null) {
					$tmp3 = !_hx_equal($v, 0);
				} else {
					$tmp3 = false;
				}
				if($tmp3) {
					$tmp2 = !_hx_equal($v, "");
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$tmp1 = $this->param->exists("filter_tables");
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					$v1 = $this->param->get("filter_tables");
					$tmp4 = null;
					if($v1 !== null) {
						$tmp4 = !_hx_equal($v1, 0);
					} else {
						$tmp4 = false;
					}
					if($tmp4) {
						$tmp = !_hx_equal($v1, "");
					} else {
						$tmp = false;
					}
					unset($v1,$tmp4);
				} else {
					$tmp = false;
				}
				if($tmp) {
					$jt = $this->param->get("filter_tables");
					$filter_tables = _hx_explode(",", $jt);
					unset($jt);
				}
				$tmp5 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
				$tmp6 = Std::string($wData) . ":";
				$tmp7 = _hx_string_or_null($tmp6) . _hx_string_or_null($this->joinTable) . ":";
				$tmp8 = _hx_string_or_null($tmp7) . Std::string($filter_tables);
				call_user_func_array($tmp5, array($tmp8, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 396, "className" => "Model", "methodName" => "buildCond"))));
				$tmp9 = null;
				$tmp10 = new EReg("^pay_[a-zA-Z_]+\\.", "");
				if($tmp10->match($wData[0])) {
					$tmp11 = _hx_array_get(_hx_explode(".", $wData[0]), 0);
					$tmp9 = $tmp11 !== $this->joinTable;
					unset($tmp11);
				} else {
					$tmp9 = false;
				}
				if($tmp9) {
					continue;
				}
				if($first) {
					$sb->add(" WHERE ");
				} else {
					$sb->add(" AND ");
				}
				$first = false;
				{
					$_g1 = strtoupper($wData[1]);
					switch($_g1) {
					case "BETWEEN":{
						$tmp12 = null;
						if($values->length !== 2) {
							$tmp12 = Lambda::hforeach($values, array(new _hx_lambda(array(), "Model_9"), 'execute'));
						} else {
							$tmp12 = false;
						}
						if($tmp12) {
							S::hexit("BETWEEN needs 2 values - got only:" . _hx_string_or_null($values->join(",")));
						}
						$sb->add($this->quoteField($wData[0]));
						$sb->add(" BETWEEN ? AND ?");
						$phValues->push((new _hx_array(array($wData[0], $values[0]))));
						$phValues->push((new _hx_array(array($wData[0], $values[1]))));
					}break;
					case "IN":{
						$sb->add($this->quoteField($wData[0]));
						$sb->add(" IN(");
						$sb->add($values->map(array(new _hx_lambda(array(&$phValues, &$values, &$wData), "Model_10"), 'execute'))->join(","));
						$sb->add(")");
					}break;
					case "LIKE":{
						$sb->add($this->quoteField($wData[0]));
						$sb->add(" LIKE ?");
						$phValues->push((new _hx_array(array($wData[0], $wData[2]))));
					}break;
					default:{
						$sb->add($this->quoteField($wData[0]));
						$tmp15 = new EReg("^(<|>)", "");
						if($tmp15->match($wData[1])) {
							$eR = new EReg("^(<|>)", "");
							$eR->match($wData[1]);
							$val = Std::parseFloat($eR->matchedRight());
							$sb->add(_hx_string_or_null($eR->matched(0)) . "?");
							$phValues->push((new _hx_array(array($wData[0], $val))));
							continue 2;
						}
						if($wData[1] === "NULL") {
							$sb->add(" IS NULL");
						} else {
							$sb->add(" = ?");
							$phValues->push((new _hx_array(array($wData[0], $wData[1]))));
						}
					}break;
					}
					unset($_g1);
				}
				unset($wData,$w,$values,$v,$tmp9,$tmp8,$tmp7,$tmp6,$tmp5,$tmp3,$tmp2,$tmp10,$tmp1,$tmp,$filter_tables);
			}
		}
		$sob->add($sb->b);
		return true;
	}
	public function buildGroup($groupParam, $sb) {
		$_gthis = $this;
		$fields = _hx_explode(",", $groupParam);
		if($fields->length === 0) {
			return false;
		}
		$sb->add(" GROUP BY ");
		$sb->add($fields->map(array(new _hx_lambda(array(&$_gthis), "Model_11"), 'execute'))->join(","));
		return true;
	}
	public function buildOrder($orderParam, $sb) {
		$_gthis = $this;
		$fields = _hx_explode(",", $orderParam);
		if($fields->length === 0) {
			return false;
		}
		$sb->add(" ORDER BY ");
		$sb->add($fields->map(array(new _hx_lambda(array(&$_gthis), "Model_12"), 'execute'))->join(","));
		return true;
	}
	public function buildLimit($limitParam, $sb) {
		$tmp = null;
		if(_hx_index_of($limitParam, ",", null) > -1) {
			$tmp = _hx_explode(",", $limitParam)->map(array(new _hx_lambda(array(), "Model_13"), 'execute'))->join(",");
		} else {
			$tmp = Std::string(Std::parseInt($limitParam));
		}
		$sb->add(" LIMIT " . _hx_string_or_null($tmp));
		return true;
	}
	public function quoteField($f) {
		$tmp = Model::$KEYWORDS;
		if($tmp->exists(strtolower($f))) {
			return "`" . _hx_string_or_null($f) . "`";
		} else {
			return $f;
		}
	}
	public function json_encode() {
		$this->data->agent = S::$user;
		$this->data->globals = $this->globals;
		return json_encode($this->data, 320);
	}
	public function json_response($res) {
		return json_encode(_hx_anonymous(array("response" => $res)), 64);
	}
	public function getEditorFields($table_name = null) {
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$param = new haxe_ds_StringMap();
		$param->set("table", "fly_crm.editor_fields");
		$tmp = null;
		if($table_name !== null) {
			$tmp = ",table_name|" . _hx_string_or_null(S::$my->real_escape_string($table_name));
		} else {
			$tmp = "";
		}
		$param->set("where", "field_cost|>-2" . _hx_string_or_null($tmp));
		$param->set("fields", "field_name,field_label,field_type,field_options,table_name");
		$param->set("order", "table_name,field_rank,field_order");
		$param->set("limit", "100");
		$a = $this->doSelect($param, $sb, $phValues);
		$eFields = new _hx_array($a);
		$ret = new haxe_ds_StringMap();
		{
			$_g = 0;
			while($_g < $eFields->length) {
				$ef = $eFields[$_g];
				$_g = $_g + 1;
				$table = $ef["table_name"];
				if(!$ret->exists($table)) {
					$ret->set($table, (new _hx_array(array())));
				}
				$a1 = $ret->get($table);
				$a1->push(php_Lib::hashOfAssociativeArray($ef));
				$ret->set($table, $a1);
				unset($table,$ef,$a1);
			}
		}
		return $ret;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $KEYWORDS;
	static function dispatch($param) {
		$cl = Type::resolveClass("model." . Std::string($param->get("className")));
		if($cl === null) {
			$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp1 = "model." . Std::string($param->get("className")) . " ???";
			call_user_func_array($tmp, array($tmp1, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 67, "className" => "Model", "methodName" => "dispatch"))));
			return false;
		}
		$fl = Reflect::field($cl, "create");
		if($fl === null) {
			$tmp2 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp3 = Std::string($cl) . "create is null";
			call_user_func_array($tmp2, array($tmp3, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 74, "className" => "Model", "methodName" => "dispatch"))));
			return false;
		}
		$iFields = Type::getInstanceFields($cl);
		if(Lambda::has($iFields, $param->get("action"))) {
			$tmp4 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp5 = "calling create " . Std::string($cl);
			call_user_func_array($tmp4, array($tmp5, _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 81, "className" => "Model", "methodName" => "dispatch"))));
			return Reflect::callMethod($cl, $fl, (new _hx_array(array($param))));
		} else {
			haxe_Log::trace("not calling create ", _hx_anonymous(array("fileName" => "Model.hx", "lineNumber" => 86, "className" => "Model", "methodName" => "dispatch")));
			return false;
		}
	}
	function __toString() { return 'Model'; }
}
Model::$KEYWORDS = Model_14();
function Model_0($f) {
	{
		return "fly_crm." . _hx_string_or_null(S::$my->real_escape_string($f));
	}
}
function Model_1($f1) {
	{
		return "fly_crm." . _hx_string_or_null(S::$my->real_escape_string($f1));
	}
}
function Model_2($f2) {
	{
		return "AND " . _hx_string_or_null($f2) . ".client_id=vicidial_list.vendor_lead_code";
	}
}
function Model_3($f3) {
	{
		return "AND " . _hx_string_or_null($f3) . ".client_id=clients.client_id";
	}
}
function Model_4($f) {
	{
		return S::$my->real_escape_string($f);
	}
}
function Model_5($f1) {
	{
		return "fly_crm." . _hx_string_or_null(S::$my->real_escape_string($f1));
	}
}
function Model_6($f2) {
	{
		return "fly_crm." . _hx_string_or_null(S::$my->real_escape_string($f2));
	}
}
function Model_7($f3) {
	{
		return "AND " . _hx_string_or_null($f3) . ".client_id=vicidial_list.vendor_lead_code";
	}
}
function Model_8($f4) {
	{
		return "AND " . _hx_string_or_null($f4) . ".client_id=clients.client_id";
	}
}
function Model_9($s) {
	{
		$tmp13 = null;
		if($s !== null) {
			$tmp13 = $s !== 0;
		} else {
			$tmp13 = false;
		}
		if($tmp13) {
			return $s !== "";
		} else {
			return false;
		}
	}
}
function Model_10(&$phValues, &$values, &$wData, $s1) {
	{
		$wData1 = $wData[0];
		$tmp14 = $values->shift();
		$phValues->push((new _hx_array(array($wData1, $tmp14))));
		return "?";
	}
}
function Model_11(&$_gthis, $g) {
	{
		return $_gthis->quoteField($g);
	}
}
function Model_12(&$_gthis, $f) {
	{
		$g = _hx_explode("|", $f);
		$tmp = $_gthis->quoteField($g[0]);
		$tmp1 = null;
		$tmp2 = null;
		if($g->length === 2) {
			$tmp2 = $g[1] === "DESC";
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$tmp1 = " DESC";
		} else {
			$tmp1 = "";
		}
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
	}
}
function Model_13($s) {
	{
		return Std::parseInt($s);
	}
}
function Model_14() {
	{
		$h = new haxe_ds_StringMap();
		{
			$_g = 0;
			$_g1 = _hx_explode("|", "ADD|ALL|ALTER|ANALYZE|AND|AS|ASC|ASENSITIVE|BEFORE|BETWEEN|BIGINT|BINARY|BLOB|BOTH|BY|CALL|CASCADE|CASE|CHANGE|CHAR|CHARACTER|CHECK|COLLATE|COLUMN|CONDITION|CONSTRAINT|CONTINUE|CONVERT|CREATE|CROSS|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATABASE|DATABASES|DAY_HOUR|DAY_MICROSECOND|DAY_MINUTE|DAY_SECOND|DEC|DECIMAL|DECLARE|DEFAULT|DELAYED|DELETE|DESC|DESCRIBE|DETERMINISTIC|DISTINCT|DISTINCTROW|DIV|DOUBLE|DROP|DUAL|EACH|ELSE|ELSEIF|ENCLOSED|ESCAPED|EXISTS|EXIT|EXPLAIN|FALSE|FETCH|FLOAT|FLOAT4|FLOAT8|FOR|FORCE|FOREIGN|FROM|FULLTEXT|GRANT|GROUP|HAVING|HIGH_PRIORITY|HOUR_MICROSECOND|HOUR_MINUTE|HOUR_SECOND|IF|IGNORE|IN|INDEX|INFILE|INNER|INOUT|INSENSITIVE|INSERT|INT|INT1|INT2|INT3|INT4|INT8|INTEGER|INTERVAL|INTO|IS|ITERATE|JOIN|KEY|KEYS|KILL|LEADING|LEAVE|LEFT|LIKE|LIMIT|LINES|LOAD|LOCALTIME|LOCALTIMESTAMP|LOCK|LONG|LONGBLOB|LONGTEXT|LOOP|LOW_PRIORITY|MATCH|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MIDDLEINT|MINUTE_MICROSECOND|MINUTE_SECOND|MOD|MODIFIES|NATURAL|NOT|NO_WRITE_TO_BINLOG|NULL|NUMERIC|ON|OPTIMIZE|OPTION|OPTIONALLY|OR|ORDER|OUT|OUTER|OUTFILE|PRECISION|PRIMARY|PROCEDURE|PURGE|READ|READS|REAL|REFERENCES|REGEXP|RELEASE|RENAME|REPEAT|REPLACE|REQUIRE|RESTRICT|RETURN|REVOKE|RIGHT|RLIKE|SCHEMA|SCHEMAS|SECOND_MICROSECOND|SELECT|SENSITIVE|SEPARATOR|SET|SHOW|SMALLINT|SONAME|SPATIAL|SPECIFIC|SQL|SQLEXCEPTION|SQLSTATE|SQLWARNING|SQL_BIG_RESULT|SQL_CALC_FOUND_ROWS|SQL_SMALL_RESULT|SSL|STARTING|STRAIGHT_JOIN|TABLE|TERMINATED|THEN|TINYBLOB|TINYINT|TINYTEXT|TO|TRAILING|TRIGGER|TRUE|UNDO|UNION|UNIQUE|UNLOCK|UNSIGNED|UPDATE|USAGE|USE|USING|UTC_DATE|UTC_TIME|UTC_TIMESTAMP|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|WHEN|WHERE|WHILE|WITH|WRITE|XOR|YEAR_MONTH|ZEROFILL|ASENSITIVE|CALL|CONDITION|CONNECTION|CONTINUE|CURSOR|DECLARE|DETERMINISTIC|EACH|ELSEIF|EXIT|FETCH|GOTO|INOUT|INSENSITIVE|ITERATE|LABEL|LEAVE|LOOP|MODIFIES|OUT|READS|RELEASE|REPEAT|RETURN|SCHEMA|SCHEMAS|SENSITIVE|SPECIFIC|SQL|SQLEXCEPTION|SQLSTATE|SQLWARNING|TRIGGER|UNDO|UPGRADE|WHILE");
			while($_g < $_g1->length) {
				$k = $_g1[$_g];
				$_g = $_g + 1;
				$h->set(strtolower($k), true);
				unset($k);
			}
		}
		return $h;
	}
}
