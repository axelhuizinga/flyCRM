<?php

// Generated by Haxe 3.4.0 (git build development @ e08d018)
class model_QC extends model_Clients {
	public function __construct($param = null) { if(!php_Boot::$skip_constructor) {
		parent::__construct($param);
	}}
	public function edit($param) {
		$cF = $this->getCustomFields($param->get("entry_list_id"));
		$cFields = $cF->map(array(new _hx_lambda(array(), "model_QC_0"), 'execute'));
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = $cFields->join(",");
		call_user_func_array($tmp, array($tmp1, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 39, "className" => "model.QC", "methodName" => "edit"))));
		$fieldDefault = new haxe_ds_StringMap();
		$fieldNames = new haxe_ds_StringMap();
		$fieldRequired = new haxe_ds_StringMap();
		$typeMap = new haxe_ds_StringMap();
		$optionsMap = new haxe_ds_StringMap();
		$eF = $this->getEditorFields(null)->get("vicidial_list");
		{
			$_g = 0;
			while($_g < $eF->length) {
				$f = $eF[$_g];
				$_g = $_g + 1;
				$tmp2 = $f->get("field_label");
				$fieldNames->set($tmp2, $f->get("field_name"));
				if($f->get("field_options") !== null) {
					$tmp3 = $f->get("field_label");
					$optionsMap->set($tmp3, $f->get("field_options"));
					unset($tmp3);
				}
				$tmp4 = $f->get("field_label");
				$typeMap->set($tmp4, $f->get("field_type"));
				unset($tmp4,$tmp2,$f);
			}
		}
		{
			$_g1 = 0;
			$_g2 = $cFields->length;
			while($_g1 < $_g2) {
				$_g1 = $_g1 + 1;
				$f1 = $_g1 - 1;
				$cFields1 = $cFields[$f1];
				$fieldNames->set($cFields1, _hx_array_get($cF, $f1)->get("field_name"));
				if(_hx_array_get($cF, $f1)->get("field_options") !== null) {
					$cFields2 = $cFields[$f1];
					$optionsMap->set($cFields2, _hx_array_get($cF, $f1)->get("field_options"));
					unset($cFields2);
				}
				$def = _hx_array_get($cF, $f1)->get("field_default");
				if($def !== null) {
					switch($def) {
					case "":case "NULL":{}break;
					default:{
						$cFields3 = $cFields[$f1];
						$fieldDefault->set($cFields3, _hx_array_get($cF, $f1)->get("field_default"));
					}break;
					}
				}
				if(_hx_array_get($cF, $f1)->get("field_required") === "Y") {
					$fieldRequired->set($cFields[$f1], true);
				}
				$cFields4 = $cFields[$f1];
				$typeMap->set($cFields4, _hx_array_get($cF, $f1)->get("field_type"));
				unset($f1,$def,$cFields4,$cFields1);
			}
		}
		$cFields->push("entry_date");
		$param->set("fields", $cFields);
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$tmp5 = php_Lib::associativeArrayOfHash($fieldDefault);
		$tmp6 = php_Lib::associativeArrayOfHash($fieldNames);
		$tmp7 = php_Lib::associativeArrayOfHash($fieldRequired);
		$tmp8 = $this->doSelectCustom($param, $sb, $phValues);
		$tmp9 = php_Lib::associativeArrayOfHash($typeMap);
		$tmp10 = php_Lib::associativeArrayOfHash($optionsMap);
		$this->data = _hx_anonymous(array("fieldDefault" => $tmp5, "fieldNames" => $tmp6, "fieldRequired" => $tmp7, "rows" => $tmp8, "typeMap" => $tmp9, "optionsMap" => $tmp10, "recordings" => $this->getRecordings(Std::parseInt($param->get("lead_id")))));
		new haxe_ds_StringMap();
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$p = new haxe_ds_StringMap();
		$p->set("table", "vicidial_users");
		$p->set("fields", "user,full_name");
		$p->set("where", "user_group|AGENTS_A");
		$tmp11 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp12 = _hx_string_rec($this->num_rows, "") . ":";
		$tmp13 = _hx_string_or_null($tmp12) . Std::string($param->get("owner"));
		call_user_func_array($tmp11, array($tmp13, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 109, "className" => "model.QC", "methodName" => "edit"))));
		$this->data->userMap = _hx_deref(new model_Users(null))->get_info(null);
		return $this->json_encode();
	}
	public function find($param) {
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$count = $this->countJoin($param, $sb, $phValues);
		haxe_Log::trace($param, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 121, "className" => "model.QC", "methodName" => "find")));
		$sb = new StringBuf();
		$phValues = new _hx_array(array());
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "count:" . _hx_string_rec($count, "") . ":" . _hx_string_or_null($param->get("page")) . ": ";
		$tmp2 = null;
		if($param->exists("page")) {
			$tmp2 = "Y";
		} else {
			$tmp2 = "N";
		}
		call_user_func_array($tmp, array(_hx_string_or_null($tmp1) . _hx_string_or_null($tmp2), _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 124, "className" => "model.QC", "methodName" => "find"))));
		$tmp3 = null;
		if($param->exists("page")) {
			$tmp3 = Std::parseInt($param->get("page"));
		} else {
			$tmp3 = 1;
		}
		$this->data = _hx_anonymous(array("count" => $count, "page" => $tmp3, "rows" => $this->doJoin($param, $sb, $phValues)));
		return $this->json_encode();
	}
	public function doSelectCustom($q, $sb, $phValues) {
		$fields = $q->get("fields");
		$tmp = null;
		if($fields !== null) {
			$tmp = $this->fieldFormat($fields->map(array(new _hx_lambda(array(), "model_QC_1"), 'execute'))->join(","));
		} else {
			$tmp = "*";
		}
		$sb->add("SELECT " . _hx_string_or_null($tmp));
		$entry_list_id = $q->get("entry_list_id");
		$primary_id = S::$my;
		$primary_id1 = $primary_id->real_escape_string($q->get("primary_id"));
		$tmp1 = " FROM " . _hx_string_or_null(S::$my->real_escape_string($this->table)) . " AS vl INNER JOIN ";
		$sb->add(_hx_string_or_null($tmp1) . _hx_string_or_null(S::$my->real_escape_string("custom_" . _hx_string_or_null($entry_list_id))) . " AS cu ON vl." . _hx_string_or_null($primary_id1) . "=cu." . _hx_string_or_null($primary_id1));
		$tmp2 = S::$my;
		$this->buildCond("vl." . _hx_string_or_null($primary_id1) . "|" . _hx_string_or_null($tmp2->real_escape_string($q->get($q->get("primary_id")))), $sb, $phValues, null);
		return $this->execute($sb->b, $phValues);
	}
	public function errSale($q) {
		$this->query("UPDATE vicidial_list SET status='NI', list_id=`entry_list_id` WHERE lead_id=" . _hx_string_rec(Std::parseInt($q->get("lead_id")), ""));
		return S::$my->affected_rows === 1;
	}
	public function save($q) {
		$lead_id = Std::parseInt($q->get("lead_id"));
		$user = S::$user;
		$tmp = null;
		if($q->exists("status")) {
			$tmp = _hx_equal($q->get("status"), "ERRSALE");
		} else {
			$tmp = false;
		}
		if($tmp) {
			return $this->errSale($q);
		}
		$log_id = false;
		$log_id = $this->saveLog($q, null);
		if($log_id) {
			$cTable = "custom_" . Std::string($q->get("entry_list_id"));
			$tmp1 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp2 = _hx_string_or_null($cTable) . " log_id:" . Std::string($log_id);
			call_user_func_array($tmp1, array($tmp2, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 173, "className" => "model.QC", "methodName" => "save"))));
			$primary_id = S::$my;
			$primary_id1 = $primary_id->real_escape_string($q->get("primary_id"));
			$sql = new StringBuf();
			$sql->add("UPDATE " . _hx_string_or_null($cTable) . " SET ");
			$cFields = S::tableFields("" . _hx_string_or_null($cTable), null);
			$tmp3 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp4 = "" . _hx_string_or_null($cTable) . " fields:" . _hx_string_or_null($cFields->toString());
			call_user_func_array($tmp3, array($tmp4, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 188, "className" => "model.QC", "methodName" => "save"))));
			$cFields->remove($primary_id1);
			$bindTypes = "";
			$values2bind = null;
			$i = 0;
			$dbFieldTypes = php_Lib::hashOfAssociativeArray(php_Lib::associativeArrayOfObject(S::$conf->get("dbFieldTypes")));
			$sets = new _hx_array(array());
			{
				$_g = 0;
				while($_g < $cFields->length) {
					$c = $cFields[$_g];
					$_g = $_g + 1;
					$val = $q->get($c);
					if($val !== null) {
						$i = $i + 1;
						$tmp5 = null;
						if(Std::is($val, _hx_qtype("String"))) {
							$tmp5 = $val;
						} else {
							$tmp5 = $val[0];
						}
						$values2bind[$i - 1] = $tmp5;
						$type = $dbFieldTypes->get($c);
						$bindTypes1 = null;
						$bindTypes2 = null;
						$bindTypes3 = null;
						if($type !== null) {
							$bindTypes3 = $type !== 0;
						} else {
							$bindTypes3 = false;
						}
						if($bindTypes3) {
							$bindTypes2 = $type !== "";
						} else {
							$bindTypes2 = false;
						}
						if($bindTypes2) {
							$bindTypes1 = $type;
						} else {
							$bindTypes1 = "s";
						}
						$bindTypes = _hx_string_or_null($bindTypes) . _hx_string_or_null($bindTypes1);
						$sets->push(_hx_string_or_null($c) . "=?");
						unset($type,$tmp5,$bindTypes3,$bindTypes2,$bindTypes1);
					}
					unset($val,$c);
				}
			}
			$sql->add($sets->join(","));
			$sql->add(" WHERE lead_id=" . _hx_string_rec($lead_id, ""));
			$stmt = S::$my->stmt_init();
			haxe_Log::trace($sql->b, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 210, "className" => "model.QC", "methodName" => "save")));
			$success = $stmt->prepare($sql->b);
			if(!$success) {
				haxe_Log::trace($stmt->error, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 214, "className" => "model.QC", "methodName" => "save")));
				return false;
			}
			$success = myBindParam($stmt, $values2bind, $bindTypes);
			$tmp6 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
			$tmp7 = "success:" . Std::string($success);
			call_user_func_array($tmp6, array($tmp7, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 218, "className" => "model.QC", "methodName" => "save"))));
			if($success) {
				$success = $stmt->execute();
				if(!$success) {
					haxe_Log::trace($stmt->error, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 224, "className" => "model.QC", "methodName" => "save")));
					return false;
				}
				$sql = new StringBuf();
				$uFields = model_QC::$vicdial_list_fields;
				$uFields->remove($primary_id1);
				$bindTypes = "";
				$values2bind = null;
				$i = 0;
				$sql->add("UPDATE vicidial_list SET ");
				$sets = new _hx_array(array());
				{
					$_g1 = 0;
					while($_g1 < $uFields->length) {
						$c1 = $uFields[$_g1];
						$_g1 = $_g1 + 1;
						$val1 = $q->get($c1);
						if($val1 !== null) {
							$i = $i + 1;
							$tmp8 = null;
							if(Std::is($val1, _hx_qtype("String"))) {
								$tmp8 = $val1;
							} else {
								$tmp8 = $val1[0];
							}
							$values2bind[$i - 1] = $tmp8;
							$type1 = $dbFieldTypes->get($c1);
							$bindTypes4 = null;
							$bindTypes5 = null;
							$bindTypes6 = null;
							if($type1 !== null) {
								$bindTypes6 = $type1 !== 0;
							} else {
								$bindTypes6 = false;
							}
							if($bindTypes6) {
								$bindTypes5 = $type1 !== "";
							} else {
								$bindTypes5 = false;
							}
							if($bindTypes5) {
								$bindTypes4 = $type1;
							} else {
								$bindTypes4 = "s";
							}
							$bindTypes = _hx_string_or_null($bindTypes) . _hx_string_or_null($bindTypes4);
							$sets->push(_hx_string_or_null($c1) . "=?");
							unset($type1,$tmp8,$bindTypes6,$bindTypes5,$bindTypes4);
						}
						unset($val1,$c1);
					}
				}
				$i = $i + 1;
				$values2bind[$i - 1] = S::$user;
				$bindTypes = _hx_string_or_null($bindTypes) . "s";
				$sets->push("security_phrase=?");
				$i = $i + 1;
				$values2bind[$i - 1] = "XX";
				$bindTypes = _hx_string_or_null($bindTypes) . "s";
				$sets->push("state=?");
				$tmp9 = null;
				if(!_hx_equal($q->get("status"), "QCOK")) {
					$tmp9 = _hx_equal($q->get("status"), "QCBAD");
				} else {
					$tmp9 = true;
				}
				if($tmp9) {
					$list_id = 10000;
					if(_hx_equal($q->get("status"), "QCOK")) {
						$mID = Std::parseInt($q->get("vendor_lead_code"));
						if($mID === null) {
							$mID = S::newMemberID();
							$i = $i + 1;
							$values2bind[$i - 1] = $mID;
							$bindTypes = _hx_string_or_null($bindTypes) . "s";
							$sets->push("vendor_lead_code=?");
						}
					} else {
						$list_id = 1800;
					}
					haxe_Log::trace("list_id:" . _hx_string_rec($list_id, ""), _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 270, "className" => "model.QC", "methodName" => "save")));
					$entry_list_id = $q->get("entry_list_id");
					$i = $i + 1;
					$values2bind[$i - 1] = $q->get("status");
					$bindTypes = _hx_string_or_null($bindTypes) . "s";
					$sets->push("`status`=?");
					$i = $i + 1;
					$values2bind[$i - 1] = $list_id;
					$bindTypes = _hx_string_or_null($bindTypes) . "s";
					$sets->push("list_id=?");
					$i = $i + 1;
					$values2bind[$i - 1] = $entry_list_id;
					$bindTypes = _hx_string_or_null($bindTypes) . "s";
					$sets->push("entry_list_id=?");
					$i = $i + 1;
					$values2bind[$i - 1] = $q->get("owner");
					$bindTypes = _hx_string_or_null($bindTypes) . "s";
					$sets->push("owner=?");
				}
				$sql->add($sets->join(","));
				$sql->add(" WHERE lead_id=" . _hx_string_rec($lead_id, ""));
				$stmt1 = S::$my->stmt_init();
				haxe_Log::trace($sql->b, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 288, "className" => "model.QC", "methodName" => "save")));
				$success1 = $stmt1->prepare($sql->b);
				if(!$success1) {
					haxe_Log::trace($stmt1->error, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 292, "className" => "model.QC", "methodName" => "save")));
					return false;
				}
				$success1 = myBindParam($stmt1, $values2bind, $bindTypes);
				$tmp10 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
				$tmp11 = "success:" . Std::string($success1);
				call_user_func_array($tmp10, array($tmp11, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 298, "className" => "model.QC", "methodName" => "save"))));
				if($success1) {
					$success1 = $stmt1->execute();
					if(!$success1) {
						haxe_Log::trace($stmt1->error, _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 304, "className" => "model.QC", "methodName" => "save")));
						return false;
					} else {
						return !_hx_equal($this->saveLog($q, $log_id), false);
					}
				}
				return false;
			}
		} else {
			haxe_Log::trace("oops", _hx_anonymous(array("fileName" => "QC.hx", "lineNumber" => 317, "className" => "model.QC", "methodName" => "save")));
		}
		return false;
	}
	static $vicdial_list_fields;
	static function create($param) {
		$self = new model_QC($param);
		$self->table = "vicidial_list";
		return Reflect::callMethod($self, Reflect::field($self, $param->get("action")), (new _hx_array(array($param))));
	}
	function __toString() { return 'model.QC'; }
}
model_QC::$vicdial_list_fields = _hx_explode(",", "lead_id,entry_date,modify_date,status,user,vendor_lead_code,source_id,list_id,gmt_offset_now,called_since_last_reset,phone_code,phone_number,title,first_name,middle_initial,last_name,address1,address2,address3,city,state,province,postal_code,country_code,gender,date_of_birth,alt_phone,email,security_phrase,comments,called_count,last_local_call_time,rank,owner,entry_list_id");
function model_QC_0($field) {
	{
		return $field->get("field_label");
	}
}
function model_QC_1($f) {
	{
		return S::$my->real_escape_string($f);
	}
}
