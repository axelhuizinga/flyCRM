<?php
/**
 * Generated by Haxe 3.4.0
 */

use \php\Boot;

class Lambda {
	/**
	 * @param object $it
	 * 
	 * @return \Array_hx
	 */
	static public function array ($it) {
		$a = new \Array_hx();
		$i = $it->iterator();
		while ($i->hasNext()) {
			$a->push($i->next());
		}

		return $a;
	}


	/**
	 * @param object $a
	 * @param object $b
	 * 
	 * @return \List_hx
	 */
	static public function concat ($a, $b) {
		$l = new \List_hx();
		$x = $a->iterator();
		while ($x->hasNext()) {
			$l->add($x->next());
		}

		$x1 = $b->iterator();
		while ($x1->hasNext()) {
			$l->add($x1->next());
		}

		return $l;
	}


	/**
	 * @param object $it
	 * @param \Closure $pred
	 * 
	 * @return int
	 */
	static public function count ($it, $pred = null) {
		$n = 0;
		if ($pred === null) {
			$_ = $it->iterator();
			while ($_->hasNext()) {
				$_->next();
				$n = $n + 1;
			}
		} else {
			$x = $it->iterator();
			while ($x->hasNext()) {
				if ($pred($x->next())) {
					$n = $n + 1;
				}
			}
		}
		return $n;
	}


	/**
	 * @param object $it
	 * 
	 * @return bool
	 */
	static public function empty ($it) {
		return !$it->iterator()->hasNext();
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return bool
	 */
	static public function exists ($it, $f) {
		$x = $it->iterator();
		while ($x->hasNext()) {
			if ($f($x->next())) {
				return true;
			}
		}

		return false;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return \List_hx
	 */
	static public function filter ($it, $f) {
		$l = new \List_hx();
		$x = $it->iterator();
		while ($x->hasNext()) {
			unset($x1);
			$x1 = $x->next();
			if ($f($x1)) {
				$l->add($x1);
			}
		}

		return $l;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return mixed
	 */
	static public function find ($it, $f) {
		$v = $it->iterator();
		while ($v->hasNext()) {
			unset($v1);
			$v1 = $v->next();
			if ($f($v1)) {
				return $v1;
			}
		}

		return null;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * @param mixed $first
	 * 
	 * @return mixed
	 */
	static public function fold ($it, $f, $first) {
		$x = $it->iterator();
		while ($x->hasNext()) {
			$first = $f($x->next(), $first);
		}

		return $first;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return bool
	 */
	static public function foreach ($it, $f) {
		$x = $it->iterator();
		while ($x->hasNext()) {
			if (!$f($x->next())) {
				return false;
			}
		}

		return true;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return bool
	 */
	static public function forone ($it, $f) {
		$x = $it->iterator();
		while ($x->hasNext()) {
			if ($f($x->next())) {
				return true;
			}
		}

		return false;
	}


	/**
	 * @param object $it
	 * @param mixed $elt
	 * 
	 * @return bool
	 */
	static public function has ($it, $elt) {
		$x = $it->iterator();
		while ($x->hasNext()) {
			if (Boot::equal($x->next(), $elt)) {
				return true;
			}
		}

		return false;
	}


	/**
	 * @param object $it
	 * @param mixed $v
	 * 
	 * @return int
	 */
	static public function indexOf ($it, $v) {
		$i = 0;
		$v2 = $it->iterator();
		while ($v2->hasNext()) {
			if (Boot::equal($v, $v2->next())) {
				return $i;
			}
			$i = $i + 1;
		}

		return -1;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return void
	 */
	static public function iter ($it, $f) {
		$x = $it->iterator();
		while ($x->hasNext()) {
			$f($x->next());
		}
	}


	/**
	 * @param object $it
	 * 
	 * @return \List_hx
	 */
	static public function list ($it) {
		$l = new \List_hx();
		$i = $it->iterator();
		while ($i->hasNext()) {
			$l->add($i->next());
		}

		return $l;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return \List_hx
	 */
	static public function map ($it, $f) {
		$l = new \List_hx();
		$x = $it->iterator();
		while ($x->hasNext()) {
			$l->add($f($x->next()));
		}

		return $l;
	}


	/**
	 * @param object $it
	 * @param \Closure $f
	 * 
	 * @return \List_hx
	 */
	static public function mapi ($it, $f) {
		$l = new \List_hx();
		$i = 0;
		$x = $it->iterator();
		while ($x->hasNext()) {
			$i = $i + 1;
			$l->add($f($i - 1, $x->next()));
		}

		return $l;
	}
}


Boot::registerClass(Lambda::class, 'Lambda');
