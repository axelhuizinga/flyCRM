<?php
/**
 * Generated by Haxe 3.4.0
 */

namespace me\cunity\debug;

use \php\Boot;
use \php\_Boot\HxException;
use \haxe\Http;
use \haxe\Log;
use \php\_Boot\HxString;
use \haxe\StackItem;
use \sys\io\File;
use \haxe\CallStack;
use \php\_Boot\HxAnon;
use \sys\io\FileOutput;

class Out {
	/**
	 * @var \Closure
	 */
	static public $aStack;
	/**
	 * @var \Array_hx
	 */
	static public $dumpedObjects;
	/**
	 * @var FileOutput
	 */
	static public $log;
	/**
	 * @var Tracer
	 */
	static public $logg;
	/**
	 * @var bool
	 */
	static public $once = false;
	/**
	 * @var \Array_hx
	 */
	static public $skipFields;
	/**
	 * @var bool
	 */
	static public $skipFunctions = true;
	/**
	 * @var bool
	 */
	static public $suspended = false;
	/**
	 * @var DebugOutput
	 */
	static public $traceTarget;
	/**
	 * @var bool
	 */
	static public $traceToConsole = false;


	/**
	 * @param mixed $v
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function _trace ($v, $i = null) {
		if (Out::$suspended) {
			return;
		}
		$warned = false;
		$tmp = null;
		if ($i !== null) {
			$tmp = \Reflect::hasField($i, "customParams");
		} else {
			$tmp = false;
		}
		if ($tmp) {
			$i = ($i->customParams->arr[0] ?? null);
		}
		$msg = null;
		if ($i !== null) {
			$msg = ($i->fileName??'null') . ":" . ($i->methodName??'null') . ":" . ($i->lineNumber??'null') . ":";
		} else {
			$msg = "";
		}
		$msg = ($msg??'null') . (\Std::string($v)??'null');
		if (Out::$log !== null) {
			Out::$log->writeString(($msg??'null') . "\x0A");
			Out::$log->flush();
		} else {
			$_g = Out::$traceTarget;
			switch ($_g->index) {
				case 0:
					echo(\Std::string(($msg??'null') . "\x0D\x0A"));
					break;
				case 1:
					$v1 = null;
					if (null) {
						$v1 = ENT_QUOTES | ENT_HTML401;
					} else {
						$v1 = ENT_NOQUOTES;
					}
					echo(\Std::string((htmlspecialchars($msg, $v1)??'null') . "<br/>"));
					break;
				case 2:
					error_log($msg);
					break;
				case 3:
										break;
			}
		}
		if (Out::$once) {
			Out::$once = false;
			Out::_trace("i:" . (\Std::string(\Type::typeof($i))??'null'), new HxAnon([
				"fileName" => "Out.hx",
				"lineNumber" => 134,
				"className" => "me.cunity.debug.Out",
				"methodName" => "_trace",
			]));
			Out::dumpObject($i, new HxAnon([
				"fileName" => "Out.hx",
				"lineNumber" => 135,
				"className" => "me.cunity.debug.Out",
				"methodName" => "_trace",
			]));
		}
	}


	/**
	 * @param mixed $ob
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function dumpObject ($ob, $i = null) {
		\Type::getClass($ob);
		$m = null;
		if ($ob !== null) {
			$m = \Type::getClass($ob);
		} else {
			$m = $ob;
		}
		$m1 = "dumpObject:" . (\Std::string($m)??'null') . "\x0A";
		$names = new \Array_hx();
		if (\Type::getClass($ob) !== null) {
			$names = \Type::getInstanceFields(\Type::getClass($ob));
		} else {
			$names = \Reflect::fields($ob);
		}
		if (\Type::getClass($ob) !== null) {
			$m1 = (\Type::getClassName(\Type::getClass($ob))??'null') . ":\x0A";
		}
		$_g = 0;
		while ($_g < $names->length) {
			unset($name, $tmp, $t);
			$name = ($names->arr[$_g] ?? null);
			$_g = $_g + 1;
			if (\Lambda::has(Out::$skipFields, $name)) {
				$m1 = ($m1??'null') . (("" . ($name??'null') . ":skipped\x0A")??'null');
				continue;
			}
			try {
				$t = \Std::string(\Type::typeof(\Reflect::field($ob, $name)));
				$tmp = null;
				if (Out::$skipFunctions) {
					$tmp = $t === "TFunction";
				} else {
					$tmp = false;
				}
				$m1 = ($m1??'null') . ((($name??'null') . ":" . (\Std::string(\Reflect::field($ob, $name))??'null') . ":" . ($t??'null') . "\x0A")??'null');
			} catch (\Throwable $__hx__caught_e) {
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				$ex = $__hx__real_e;
				$m1 = ($m1??'null') . ((($name??'null') . ":" . (\Std::string($ex)??'null'))??'null');
			}
		}

		Out::_trace($m1, $i);
	}


	/**
	 * @param \Array_hx $sA
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function dumpStack ($sA, $i = null) {
		$b = new \StringBuf();
		$b->add("StackDump:" . ($sA->length??'null') . "<br/>");
		$_g = 0;
		while ($_g < $sA->length) {
			unset($item);
			$item = ($sA->arr[$_g] ?? null);
			$_g = $_g + 1;
			Out::itemToString($item, $b);
			$b->add("<br/>");
		}

		(Log::$trace)($b->b, new HxAnon([
			"fileName" => "Out.hx",
			"lineNumber" => 429,
			"className" => "me.cunity.debug.Out",
			"methodName" => "dumpStack",
			"customParams" => \Array_hx::wrap([$i]),
		]));
	}


	/**
	 * @param mixed $v
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function dumpVar ($v, $i = null) {
		
			ob_start();
			print_r($v);
			$ret =  ob_get_clean();
		;
		Out::_trace($ret, new HxAnon([
			"fileName" => "Out.hx",
			"lineNumber" => 347,
			"className" => "me.cunity.debug.Out",
			"methodName" => "dumpVar",
		]));
	}


	/**
	 * @param string $str
	 * @param \Array_hx $arr
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function fTrace ($str, $arr, $i = null) {
		$str_arr = HxString::split($str, " @");
		$str_buf = new \StringBuf();
		$_g1 = 0;
		$_g = $str_arr->length;
		while ($_g1 < $_g) {
			unset($i1);
			$_g1 = $_g1 + 1;
			$i1 = $_g1 - 1;
			$str_buf->add(($str_arr->arr[$i1] ?? null));
			if (($arr->arr[$i1] ?? null) !== null) {
				$str_buf->add(($arr->arr[$i1] ?? null));
			}
		}

		Out::_trace($str_buf->b, $i);
	}


	/**
	 * @return void
	 */
	static public function init () {
		File::saveContent("log.txt", "");
		Out::$log = File::write("log.txt", true);
		Out::$log->flush();
		Log::$trace = function($v, $i = null) { return Out::_trace($v, $i); };
	}


	/**
	 * @param StackItem $s
	 * @param \StringBuf $b
	 * 
	 * @return void
	 */
	static public function itemToString ($s, $b) {
		switch ($s->index) {
			case 0:
				$b->add("a C function");
				break;
			case 1:
				$b->add("module ");
				$b->add($s->params[0]);
				break;
			case 2:
				$s1 = $s->params[0];
				if ($s1 !== null) {
					Out::itemToString($s1, $b);
					$b->add(" (");
				}
				$b->add($s->params[1]);
				$b->add(" line ");
				$b->add($s->params[2]);
				if ($s1 !== null) {
					$b->add(")<br/>");
				}

				break;
			case 3:
				$b->add($s->params[0]);
				$b->add(".");
				$b->add($s->params[1]);
				$b->add("<br/>");
				break;
			case 4:
				$b->add("LocalFunction:" . ($s->params[0]??'null'));
				break;
		}
	}


	/**
	 * @param mixed $v
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function log2 ($v, $i = null) {
		$msg = null;
		if ($i !== null) {
			$msg = ($i->fileName??'null') . ":" . ($i->lineNumber??'null') . ":" . ($i->methodName??'null') . ":";
		} else {
			$msg = "";
		}
		$msg = ($msg??'null') . (\Std::string($v)??'null');
		$http = new Http("http://localhost/devel/php/jsLog.php");
		$http->setParameter("log", $msg);
		$http->onData = function ($data) {
			if ($data !== "OK") {
				(Log::$trace)($data, new HxAnon([
					"fileName" => "Out.hx",
					"lineNumber" => 203,
					"className" => "me.cunity.debug.Out",
					"methodName" => "log2",
				]));
			}
		};
		$http->request(true);
	}


	/**
	 * @param string $data
	 * @param object $i
	 * 
	 * @return void
	 */
	static public function printCDATA ($data, $i = null) {
		Out::_trace("<pre>" . (((htmlspecialchars ($data)??'null') . "</pre>")??'null'), $i);
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$aStack = function() { return CallStack::callStack(); };
		self::$skipFields = new \Array_hx();
		self::$traceTarget = DebugOutput::NATIVE();
	}
}


Boot::registerClass(Out::class, 'me.cunity.debug.Out');
Out::__hx__init();
