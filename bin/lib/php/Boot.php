<?php
/**
 * Generated by Haxe 3.4.0
 */

namespace php;

use \php\_Boot\HxClosure;
use \php\_Boot\HxException;
use \php\_Boot\HxDynamicStr;
use \php\_Boot\HxString;
use \php\_Boot\HxClass;
use \php\_Boot\HxEnum;
use \php\_Boot\HxAnon;

class Boot {
	const PHP_PREFIX = "";


	/**
	 * @var mixed
	 */
	static protected $aliases;
	/**
	 * @var mixed
	 */
	static protected $classes;
	/**
	 * @var mixed
	 */
	static protected $getters;
	/**
	 * @var mixed
	 */
	static protected $meta;
	/**
	 * @var mixed
	 */
	static protected $setters;


	/**
	 * @param mixed $left
	 * @param mixed $right
	 * 
	 * @return mixed
	 */
	static public function addOrConcat ($left, $right) {
		$tmp = null;
		$tmp1 = null;
		if (!is_string($left)) {
			$tmp1 = $left === null;
		} else {
			$tmp1 = true;
		}
		if ($tmp1) {
			$tmp2 = null;
			if (!is_string($right)) {
				$tmp2 = $right === null;
			} else {
				$tmp2 = true;
			}
			if (!$tmp2) {
				if (!is_int($right)) {
					$tmp = is_float($right);
				} else {
					$tmp = true;
				}
			} else {
				$tmp = true;
			}
		} else {
			$tmp = false;
		}
		if ($tmp) {
			return ($left??'null') . ($right??'null');
		}
		return ($left + $right);
	}


	/**
	 * @param mixed $value
	 * 
	 * @return HxClosure
	 */
	static public function castClosure ($value) {
		return $value;
	}


	/**
	 * @param mixed $target
	 * @param mixed $func
	 * 
	 * @return HxClosure
	 */
	static public function closure ($target, $func) {
		return new HxClosure($target, $func);
	}


	/**
	 * @return HxClass
	 */
	static public function closureHxClass () {
		return Boot::getClass(HxClosure::class);
	}


	/**
	 * @param mixed $data
	 * 
	 * @return mixed
	 */
	static public function createAnon ($data) {
		return new HxAnon($data);
	}


	/**
	 * @param mixed $value
	 * 
	 * @return mixed
	 */
	static public function deref ($value) {
		return $value;
	}


	/**
	 * @param string $phpClassName
	 * 
	 * @return bool
	 */
	static public function ensureLoaded ($phpClassName) {
		if (!class_exists($phpClassName)) {
			return interface_exists($phpClassName);
		} else {
			return true;
		}
	}


	/**
	 * @param mixed $left
	 * @param mixed $right
	 * 
	 * @return bool
	 */
	static public function equal ($left, $right) {
		$tmp = null;
		$tmp1 = null;
		if (!is_int($left)) {
			$tmp1 = is_float($left);
		} else {
			$tmp1 = true;
		}
		if ($tmp1) {
			if (!is_int($right)) {
				$tmp = is_float($right);
			} else {
				$tmp = true;
			}
		} else {
			$tmp = false;
		}
		if ($tmp) {
			return ($left == $right);
		}
		return ($left === $right);
	}


	/**
	 * @param string $phpClassName
	 * 
	 * @return HxClass
	 */
	static public function getClass ($phpClassName) {
		if (HxString::charAt($phpClassName, 0) === "\\") {
			$phpClassName = HxString::substr($phpClassName, 1);
		}
		if (!isset(Boot::$classes[$phpClassName])) {
			Boot::$classes[$phpClassName] = new HxClass($phpClassName);
		}
		return Boot::$classes[$phpClassName];
	}


	/**
	 * @param string $phpClassName
	 * 
	 * @return string
	 */
	static public function getClassName ($phpClassName) {
		$hxClass = Boot::getClass($phpClassName);
		$name = Boot::getHaxeName($hxClass);
		if ($name === null) {
			return $hxClass->phpClassName;
		} else {
			return $name;
		}
	}


	/**
	 * @param HxClass $hxClass
	 * 
	 * @return string
	 */
	static public function getHaxeName ($hxClass) {
		switch ($hxClass->phpClassName) {
			case "Bool":
				return "Bool";
				break;
			case "Class":
				return "Class";
				break;
			case "Dynamic":
				return "Dynamic";
				break;
			case "Enum":
				return "Enum";
				break;
			case "Float":
				return "Float";
				break;
			case "Int":
				return "Int";
				break;
			case "String":
				return "String";
				break;
			default:
								break;
		}
		if (isset(Boot::$aliases[$hxClass->phpClassName])) {
			return Boot::$aliases[$hxClass->phpClassName];
		} else {
			$tmp = null;
			if (class_exists($hxClass->phpClassName)) {
				$tmp = isset(Boot::$aliases[$hxClass->phpClassName]);
			} else {
				$tmp = false;
			}
			if ($tmp) {
				return Boot::$aliases[$hxClass->phpClassName];
			} else {
				$tmp1 = null;
				if (interface_exists($hxClass->phpClassName)) {
					$tmp1 = isset(Boot::$aliases[$hxClass->phpClassName]);
				} else {
					$tmp1 = false;
				}
				if ($tmp1) {
					return Boot::$aliases[$hxClass->phpClassName];
				}
			}
		}
		return null;
	}


	/**
	 * @return HxClass
	 */
	static public function getHxAnon () {
		return Boot::getClass(HxAnon::class);
	}


	/**
	 * @return HxClass
	 */
	static public function getHxClass () {
		return Boot::getClass(HxClass::class);
	}


	/**
	 * @param string $phpClassName
	 * 
	 * @return mixed
	 */
	static public function getMeta ($phpClassName) {
		if (!class_exists($phpClassName)) {
			interface_exists($phpClassName);
		}
		if (isset(Boot::$meta[$phpClassName])) {
			return Boot::$meta[$phpClassName];
		} else {
			return null;
		}
	}


	/**
	 * @param string $haxeName
	 * 
	 * @return string
	 */
	static public function getPhpName ($haxeName) {
		$prefix = self::PHP_PREFIX;
		$phpParts = null;
		if (strlen($prefix) === 0) {
			$phpParts = new \Array_hx();
		} else {
			$phpParts = \Array_hx::wrap([$prefix]);
		}
		$haxeParts = HxString::split($haxeName, ".");
		$_g = 0;
		while ($_g < $haxeParts->length) {
			unset($part);
			$part = ($haxeParts->arr[$_g] ?? null);
			$_g = $_g + 1;
			switch (HxString::toLowerCase($part)) {
				case "__class__":
				case "__dir__":
				case "__file__":
				case "__function__":
				case "__halt_compiler":
				case "__line__":
				case "__method__":
				case "__namespace__":
				case "__trait__":
				case "abstract":
				case "and":
				case "array":
				case "as":
				case "bool":
				case "break":
				case "callable":
				case "case":
				case "catch":
				case "class":
				case "clone":
				case "const":
				case "continue":
				case "declare":
				case "default":
				case "die":
				case "do":
				case "echo":
				case "else":
				case "elseif":
				case "empty":
				case "enddeclare":
				case "endfor":
				case "endforeach":
				case "endif":
				case "endswitch":
				case "endwhile":
				case "eval":
				case "exit":
				case "extends":
				case "false":
				case "final":
				case "finally":
				case "float":
				case "for":
				case "foreach":
				case "function":
				case "global":
				case "goto":
				case "if":
				case "implements":
				case "include":
				case "include_once":
				case "instanceof":
				case "insteadof":
				case "int":
				case "interface":
				case "isset":
				case "iterable":
				case "list":
				case "namespace":
				case "new":
				case "null":
				case "or":
				case "parent":
				case "print":
				case "private":
				case "protected":
				case "public":
				case "require":
				case "require_once":
				case "return":
				case "static":
				case "string":
				case "switch":
				case "throw":
				case "trait":
				case "true":
				case "try":
				case "unset":
				case "use":
				case "var":
				case "void":
				case "while":
				case "xor":
				case "yield":
					$part = ($part??'null') . "_hx";
					break;
				default:
										break;
			}
			$phpParts->push($part);
		}

		return $phpParts->join("\\");
	}


	/**
	 * @return string
	 */
	static public function getPrefix () {
		return self::PHP_PREFIX;
	}


	/**
	 * @param string $phpClassName
	 * @param string $property
	 * 
	 * @return bool
	 */
	static public function hasGetter ($phpClassName, $property) {
		if (!class_exists($phpClassName)) {
			interface_exists($phpClassName);
		}
		$has = false;
		$phpClassName1 = $phpClassName;
		while (true) {
			unset($tmp, $tmp1);
			$has = isset(Boot::$getters[$phpClassName1][$property]);
			$phpClassName1 = get_parent_class($phpClassName1);
			$tmp = null;
			$tmp1 = null;
			if (!$has) {
				$tmp1 = $phpClassName1 !== false;
			} else {
				$tmp1 = false;
			}
			if ($tmp1) {
				$tmp = class_exists($phpClassName1);
			} else {
				$tmp = false;
			}
			if (!$tmp) {
				break;
			}
		}
		return $has;
	}


	/**
	 * @param string $phpClassName
	 * @param string $property
	 * 
	 * @return bool
	 */
	static public function hasSetter ($phpClassName, $property) {
		if (!class_exists($phpClassName)) {
			interface_exists($phpClassName);
		}
		$has = false;
		$phpClassName1 = $phpClassName;
		while (true) {
			unset($tmp, $tmp1);
			$has = isset(Boot::$setters[$phpClassName1][$property]);
			$phpClassName1 = get_parent_class($phpClassName1);
			$tmp = null;
			$tmp1 = null;
			if (!$has) {
				$tmp1 = $phpClassName1 !== false;
			} else {
				$tmp1 = false;
			}
			if ($tmp1) {
				$tmp = class_exists($phpClassName1);
			} else {
				$tmp = false;
			}
			if (!$tmp) {
				break;
			}
		}
		return $has;
	}


	/**
	 * @param mixed $value
	 * @param HxClass $type
	 * 
	 * @return bool
	 */
	static public function is ($value, $type) {
		if ($type === null) {
			return false;
		}
		$phpType = $type->phpClassName;
		switch ($phpType) {
			case "Bool":
				return is_bool($value);
				break;
			case "Dynamic":
				return true;
				break;
			case "Class":
			case "Enum":
				$tmp = $value;
				$tmp1 = Boot::getClass(HxClass::class);
				if ($tmp instanceof $tmp1->phpClassName) {
					$isEnumType = is_subclass_of($value->phpClassName, Boot::getClass(HxEnum::class)->phpClassName);
					if ($phpType === "Enum") {
						return $isEnumType;
					} else {
						return !$isEnumType;
					}
				}
				break;
			case "Float":
				if (!is_float($value)) {
					return is_int($value);
				} else {
					return true;
				}
				break;
			case "Int":
				$tmp2 = null;
				if (!is_int($value)) {
					$tmp3 = null;
					if (is_float($value)) {
						$tmp3 = ((int)$value == $value);
					} else {
						$tmp3 = false;
					}
					if ($tmp3) {
						$tmp2 = !is_nan($value);
					} else {
						$tmp2 = false;
					}
				} else {
					$tmp2 = true;
				}
				if ($tmp2) {
					return abs($value) <= 2147483648;
				} else {
					return false;
				}
				break;
			case "String":
				return is_string($value);
				break;
			case "php\\NativeArray":
			case "php\\_NativeArray\\NativeArray_Impl_":
				return is_array($value);
				break;
			default:
				if (is_object($value)) {
					$tmp4 = $value;
					$tmp5 = $type;
					return $tmp4 instanceof $tmp5->phpClassName;
				}
				break;
		}
		return false;
	}


	/**
	 * @param mixed $value
	 * 
	 * @return bool
	 */
	static public function isClass ($value) {
		$tmp = $value;
		$tmp1 = Boot::getClass(HxClass::class);
		return $tmp instanceof $tmp1->phpClassName;
	}


	/**
	 * @param mixed $value
	 * 
	 * @return bool
	 */
	static public function isEnumValue ($value) {
		$tmp = $value;
		$tmp1 = Boot::getClass(HxEnum::class);
		return $tmp instanceof $tmp1->phpClassName;
	}


	/**
	 * @param mixed $value
	 * 
	 * @return bool
	 */
	static public function isNumber ($value) {
		if (!is_int($value)) {
			return is_float($value);
		} else {
			return true;
		}
	}


	/**
	 * @param string $phpClassName
	 * @param string $haxeClassName
	 * 
	 * @return void
	 */
	static public function registerClass ($phpClassName, $haxeClassName) {
		Boot::$aliases[$phpClassName] = $haxeClassName;
	}


	/**
	 * @param string $phpClassName
	 * @param mixed $list
	 * 
	 * @return void
	 */
	static public function registerGetters ($phpClassName, $list) {
		Boot::$getters[$phpClassName] = $list;
	}


	/**
	 * @param string $phpClassName
	 * @param mixed $data
	 * 
	 * @return void
	 */
	static public function registerMeta ($phpClassName, $data) {
		Boot::$meta[$phpClassName] = $data;
	}


	/**
	 * @param string $phpClassName
	 * @param mixed $list
	 * 
	 * @return void
	 */
	static public function registerSetters ($phpClassName, $list) {
		Boot::$setters[$phpClassName] = $list;
	}


	/**
	 * @param int $left
	 * @param int $right
	 * 
	 * @return int
	 */
	static public function shiftRightUnsigned ($left, $right) {
		if ($right === 0) {
			return $left;
		} else if ($left >= 0) {
			return $left >> $right;
		} else {
			return ($left >> $right) & (2147483647 >> ($right - 1));
		}
	}


	/**
	 * @param mixed $value
	 * 
	 * @return string
	 */
	static public function stringify ($value) {
		if ($value === null) {
			return "null";
		}
		if (is_string($value)) {
			return $value;
		}
		$tmp = null;
		if (!is_int($value)) {
			$tmp = is_float($value);
		} else {
			$tmp = true;
		}
		if ($tmp) {
			return (string)$value;
		}
		if (is_bool($value)) {
			if ($value) {
				return "true";
			} else {
				return "false";
			}
		}
		if (is_array($value)) {
			$strings = [];
			foreach ($value as $key => $item) {
				$tmp1 = ($key??'null') . " => " . (Boot::stringify($item)??'null');
				array_push($strings, $tmp1);
			};
			return "[" . (implode(", ", $strings)??'null') . "]";
		}
		if (is_object($value)) {
			if (method_exists($value, "toString")) {
				return HxDynamicStr::wrap($value)->toString();
			}
			if (method_exists($value, "__toString")) {
				return $value->__toString();
			}
			$tmp2 = $value;
			$tmp3 = Boot::getClass(\StdClass::class);
			if ($tmp2 instanceof $tmp3->phpClassName) {
				$tmp4 = null;
				if (isset(HxDynamicStr::wrap($value)->toString)) {
					$tmp4 = is_callable(HxDynamicStr::wrap($value)->toString);
				} else {
					$tmp4 = false;
				}
				if ($tmp4) {
					return HxDynamicStr::wrap($value)->toString();
				}
				$result = [];
				$data = get_object_vars($value);
				$_g_hasMore = null;
				$this1 = array_keys($data);
				$_g_hasMore = reset($this1) !== false;
				while ($_g_hasMore) {
					unset($result1, $key1);
					$result1 = current($this1);
					$_g_hasMore = next($this1) !== false;
					$key1 = $result1;
					array_push($result, "" . ($key1??'null') . " : " . (Boot::stringify($data[$key1])??'null'));
				}

				return "{ " . (implode(", ", $result)??'null') . " }";
			}
			$tmp5 = null;
			$tmp6 = $value;
			$tmp7 = Boot::getClass(HxClosure::class);
			if (!$tmp6 instanceof $tmp7->phpClassName) {
				$tmp8 = $value;
				$tmp9 = Boot::getClass(\Closure::class);
				$tmp5 = $tmp8 instanceof $tmp9->phpClassName;
			} else {
				$tmp5 = true;
			}
			if ($tmp5) {
				return "<function>";
			}
			$tmp10 = $value;
			$tmp11 = Boot::getClass(HxClass::class);
			if ($tmp10 instanceof $tmp11->phpClassName) {
				return "[class " . (Boot::getClassName($value->phpClassName)??'null') . "]";
			} else {
				return "[object " . (Boot::getClassName(get_class($value))??'null') . "]";
			}
		}
		throw new HxException("Unable to stringify value");
	}


	/**
	 * @param mixed $value
	 * @param object $infos
	 * 
	 * @return void
	 */
	static public function trace ($value, $infos) {
		if ($infos !== null) {
			echo("" . ($infos->fileName??'null') . ":" . ($infos->lineNumber??'null') . ": ");
		}
		echo(Boot::stringify($value));
		if ($infos->customParams !== null) {
			$_g = 0;
			$_g1 = $infos->customParams;
			while ($_g < $_g1->length) {
				unset($value1);
				$value1 = ($_g1->arr[$_g] ?? null);
				$_g = $_g + 1;
				echo("," . (Boot::stringify($value1)??'null'));
			}
		}
		echo("\x0A");
	}


	/**
	 * @param HxClass $hxClass
	 * @param mixed $value
	 * 
	 * @return mixed
	 */
	static public function typedCast ($hxClass, $value) {
		switch ($hxClass->phpClassName) {
			case "Bool":
				if (is_bool($value)) {
					return $value;
				}
				break;
			case "Float":
				$tmp = null;
				if (!is_int($value)) {
					$tmp = is_float($value);
				} else {
					$tmp = true;
				}
				if ($tmp) {
					return floatval($value);
				}
				break;
			case "Int":
				$tmp1 = null;
				if (!is_int($value)) {
					$tmp1 = is_float($value);
				} else {
					$tmp1 = true;
				}
				if ($tmp1) {
					return intval($value);
				}
				break;
			case "String":
				if (is_string($value)) {
					return $value;
				}
				break;
			case "php\\NativeArray":
				if (is_array($value)) {
					return $value;
				}
				break;
			default:
				$tmp2 = null;
				if (is_object($value)) {
					$tmp2 = Boot::is($value, $hxClass);
				} else {
					$tmp2 = false;
				}
				if ($tmp2) {
					return $value;
				}
				break;
		}
		throw new HxException("Cannot cast " . (\Std::string($value)??'null') . " to " . (Boot::getClassName($hxClass->phpClassName)??'null'));
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;

		$tmp = null;
		if (!(!defined("HAXE_CUSTOM_ERROR_HANDLER"))) {
			$tmp = !HAXE_CUSTOM_ERROR_HANDLER;
		} else {
			$tmp = true;
		}
		if ($tmp) {
			$previousLevel = error_reporting(E_ALL);
			$previousHandler = set_error_handler(function ($errno, $errstr, $errfile, $errline) {
				if ((error_reporting() & $errno) === 0) {
					return false;
				}
				throw new \ErrorException($errstr, 0, $errno, $errfile, $errline);
			});
			if ($previousHandler !== null) {
				error_reporting($previousLevel);
				set_error_handler($previousHandler);
			}
		}

		self::$aliases = [];
		self::$classes = [];
		self::$getters = [];
		self::$meta = [];
		self::$setters = [];
	}
}


Boot::__hx__init();
Boot::registerClass(Boot::class, 'php.Boot');
\php\Web::__hx__init();
\php\Session::__hx__init();
\S::__hx__init();
