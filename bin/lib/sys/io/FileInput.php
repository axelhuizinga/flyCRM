<?php
/**
 * Generated by Haxe 3.4.0
 */

namespace sys\io;

use \haxe\io\Eof;
use \php\Boot;
use \php\_Boot\HxException;
use \haxe\io\Input;
use \haxe\io\Bytes;
use \haxe\io\_BytesData\Container;
use \haxe\io\Error;

class FileInput extends Input {
	/**
	 * @var mixed
	 */
	public $__f;


	/**
	 * @param mixed $f
	 * 
	 * @return void
	 */
	public function __construct ($f) {
		$this->__f = $f;
	}


	/**
	 * @return void
	 */
	public function close () {
		parent::close();
		if ($this->__f !== null) {
			fclose($this->__f);
		}
	}


	/**
	 * @return int
	 */
	public function readByte () {
		$r = fread($this->__f, 1);
		if (feof($this->__f)) {
			throw new HxException(new Eof());
		}
		if ($r === false) {
			throw new HxException(Error::Custom("An error occurred"));
		}
		return ord($r);
	}


	/**
	 * @param Bytes $s
	 * @param int $p
	 * @param int $l
	 * 
	 * @return int
	 */
	public function readBytes ($s, $p, $l) {
		if (feof($this->__f)) {
			throw new HxException(new Eof());
		}
		$r = fread($this->__f, $l);
		if ($r === false) {
			throw new HxException(Error::Custom("An error occurred"));
		}
		$b = new Bytes($r->length, new Container($r));
		$len = strlen($r);
		$tmp = null;
		$tmp1 = null;
		$tmp2 = null;
		if ($p >= 0) {
			$tmp2 = $len < 0;
		} else {
			$tmp2 = true;
		}
		if (!$tmp2) {
			$tmp1 = ($p + $len) > $s->length;
		} else {
			$tmp1 = true;
		}
		if (!$tmp1) {
			$tmp = $len > $b->length;
		} else {
			$tmp = true;
		}
		if ($tmp) {
			throw new HxException(Error::OutsideBounds());
		} else {
			$this1 = $s->b;
			$src = $b->b;
			$this1->s = ((substr($this1->s, 0, $p) . substr($src->s, 0, $len)) . substr($this1->s, $p + $len));
		}

		return strlen($r);
	}
}


Boot::registerClass(FileInput::class, 'sys.io.FileInput');
