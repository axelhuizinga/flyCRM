<?php
/**
 * Generated by Haxe 3.4.0
 */

namespace haxe;

use \haxe\io\Eof;
use \php\_Boot\HxClosure;
use \haxe\io\Output;
use \haxe\ds\StringMap;
use \php\Boot;
use \php\_Boot\HxException;
use \haxe\io\BytesBuffer;
use \sys\net\Host;
use \php\_Boot\HxString;
use \haxe\io\Bytes;
use \haxe\io\_BytesData\Container;
use \haxe\io\BytesOutput;
use \php\_Boot\HxAnon;
use \haxe\io\Error;
use \php\net\SslSocket;
use \sys\net\Socket;

class Http {
	/**
	 * @var object
	 */
	static public $PROXY = null;


	/**
	 * @var Bytes
	 */
	public $chunk_buf;
	/**
	 * @var int
	 */
	public $chunk_size;
	/**
	 * @var float
	 */
	public $cnxTimeout;
	/**
	 * @var object
	 */
	public $file;
	/**
	 * @var \List_hx
	 */
	public $headers;
	/**
	 * @var bool
	 */
	public $noShutdown;
	/**
	 * @var \Closure
	 */
	public $onData;
	/**
	 * @var \Closure
	 */
	public $onError;
	/**
	 * @var \Closure
	 */
	public $onStatus;
	/**
	 * @var \List_hx
	 */
	public $params;
	/**
	 * @var string
	 */
	public $postData;
	/**
	 * @var string
	 */
	public $responseData;
	/**
	 * @var StringMap
	 */
	public $responseHeaders;
	/**
	 * @var string
	 */
	public $url;


	/**
	 * @param string $url
	 * 
	 * @return string
	 */
	static public function requestUrl ($url) {
		$h = new Http($url);
		$r = null;
		$h->onData = function ($d)  use (&$r) {
			$r = $d;
		};
		$h->onError = function ($e) {
			throw new HxException($e);
		};
		$h->request(false);
		return $r;
	}


	/**
	 * @param string $url
	 * 
	 * @return void
	 */
	public function __construct ($url) {
		if (!$this->__hx__default__onData) {
			$this->__hx__default__onData = new HxClosure($this, 'onData');
			if ($this->onData === null) $this->onData = $this->__hx__default__onData;
		}
		if (!$this->__hx__default__onError) {
			$this->__hx__default__onError = new HxClosure($this, 'onError');
			if ($this->onError === null) $this->onError = $this->__hx__default__onError;
		}
		if (!$this->__hx__default__onStatus) {
			$this->__hx__default__onStatus = new HxClosure($this, 'onStatus');
			if ($this->onStatus === null) $this->onStatus = $this->__hx__default__onStatus;
		}
		$this->url = $url;
		$this->headers = new \List_hx();
		$this->params = new \List_hx();
		$this->cnxTimeout = 10;
		$this->noShutdown = !function_exists("stream_socket_shutdown");
	}


	/**
	 * @param bool $post
	 * @param Output $api
	 * @param Socket $sock
	 * @param string $method
	 * 
	 * @return void
	 */
	public function customRequest ($post, $api, $sock = null, $method = null) {
		$this->responseData = null;
		$url_regexp = new \EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)\$", "");
		if (!$url_regexp->match($this->url)) {
			$this->onError("Invalid URL");
			return;
		}
		$secure = $url_regexp->matched(1) === "https://";
		if ($sock === null) {
			if ($secure) {
				$sock = new SslSocket();
			} else {
				$sock = new Socket();
			}
		}
		$host = $url_regexp->matched(2);
		$portString = $url_regexp->matched(3);
		$request = $url_regexp->matched(4);
		if ($request === "") {
			$request = "/";
		}
		$port = null;
		$port1 = null;
		if ($portString !== null) {
			$port1 = $portString === "";
		} else {
			$port1 = true;
		}
		if ($port1) {
			if ($secure) {
				$port = 443;
			} else {
				$port = 80;
			}
		} else {
			$port = \Std::parseInt(HxString::substr($portString, 1, strlen($portString) - 1));
		}
		$multipart = $this->file !== null;
		$boundary = null;
		$uri = null;
		if ($multipart) {
			$post = true;
			$boundary = (\Std::string(\Std::random(1000))??'null') . (\Std::string(\Std::random(1000))??'null') . (\Std::string(\Std::random(1000))??'null') . (\Std::string(\Std::random(1000))??'null');
			while (strlen($boundary) < 38) {
				$boundary = "-" . ($boundary??'null');
			}
			$b = new \StringBuf();
			$_g_head = $this->params->h;
			while ($_g_head !== null) {
				unset($val);
				$val = $_g_head->item;
				$_g_head = $_g_head->next;
				$b->add("--");
				$b->add($boundary);
				$b->add("\x0D\x0A");
				$b->add("Content-Disposition: form-data; name=\"");
				$b->add($val->param);
				$b->add("\"");
				$b->add("\x0D\x0A");
				$b->add("\x0D\x0A");
				$b->add($val->value);
				$b->add("\x0D\x0A");
			}

			$b->add("--");
			$b->add($boundary);
			$b->add("\x0D\x0A");
			$b->add("Content-Disposition: form-data; name=\"");
			$b->add($this->file->param);
			$b->add("\"; filename=\"");
			$b->add($this->file->filename);
			$b->add("\"");
			$b->add("\x0D\x0A");
			$b->add("Content-Type: " . ($this->file->mimeType??'null') . "\x0D\x0A" . "\x0D\x0A");
			$uri = $b->b;
		} else {
			$_g_head1 = $this->params->h;
			while ($_g_head1 !== null) {
				unset($val1);
				$val1 = $_g_head1->item;
				$_g_head1 = $_g_head1->next;
				if ($uri === null) {
					$uri = "";
				} else {
					$uri = ($uri??'null') . "&";
				}
				$uri = ($uri??'null') . (((rawurlencode($val1->param)??'null') . "=" . (rawurlencode($val1->value)??'null'))??'null');
			}
		}
		$b1 = new \StringBuf();
		if ($method !== null) {
			$b1->add($method);
			$b1->add(" ");
		} else if ($post) {
			$b1->add("POST ");
		} else {
			$b1->add("GET ");
		}
		if (Http::$PROXY !== null) {
			$b1->add("http://");
			$b1->add($host);
			if ($port !== 80) {
				$b1->add(":");
				$b1->add($port);
			}
		}
		$b1->add($request);
		$tmp = null;
		if (!$post) {
			$tmp = $uri !== null;
		} else {
			$tmp = false;
		}
		if ($tmp) {
			if (HxString::indexOf($request, "?", 0) >= 0) {
				$b1->add("&");
			} else {
				$b1->add("?");
			}
			$b1->add($uri);
		}
		$b1->add(" HTTP/1.1\x0D\x0AHost: " . ($host??'null') . "\x0D\x0A");
		if ($this->postData !== null) {
			$b1->add("Content-Length: " . (strlen($this->postData)??'null') . "\x0D\x0A");
		} else {
			$tmp1 = null;
			if ($post) {
				$tmp1 = $uri !== null;
			} else {
				$tmp1 = false;
			}
			if ($tmp1) {
				$tmp2 = null;
				if (!$multipart) {
					$tmp2 = !\Lambda::exists($this->headers, function ($h) {
						return $h->header === "Content-Type";
					});
				} else {
					$tmp2 = true;
				}
				if ($tmp2) {
					$b1->add("Content-Type: ");
					if ($multipart) {
						$b1->add("multipart/form-data");
						$b1->add("; boundary=");
						$b1->add($boundary);
					} else {
						$b1->add("application/x-www-form-urlencoded");
					}
					$b1->add("\x0D\x0A");
				}
				if ($multipart) {
					$b1->add("Content-Length: " . ((strlen($uri) + $this->file->size + strlen($boundary) + 6)??'null') . "\x0D\x0A");
				} else {
					$b1->add("Content-Length: " . (strlen($uri)??'null') . "\x0D\x0A");
				}
			}
		}
		$b1->add("Connection: close\x0D\x0A");
		$_g_head2 = $this->headers->h;
		while ($_g_head2 !== null) {
			unset($val2);
			$val2 = $_g_head2->item;
			$_g_head2 = $_g_head2->next;
			$b1->add($val2->header);
			$b1->add(": ");
			$b1->add($val2->value);
			$b1->add("\x0D\x0A");
		}

		$b1->add("\x0D\x0A");
		if ($this->postData !== null) {
			$b1->add($this->postData);
		} else {
			$tmp3 = null;
			if ($post) {
				$tmp3 = $uri !== null;
			} else {
				$tmp3 = false;
			}
			if ($tmp3) {
				$b1->add($uri);
			}
		}
		try {
			if (Http::$PROXY !== null) {
				$sock->connect(new Host(Http::$PROXY->host), Http::$PROXY->port);
			} else {
				$sock->connect(new Host($host), $port);
			}
			$sock->write($b1->b);
			if ($multipart) {
				$buf = Bytes::alloc(4096);
				while ($this->file->size > 0) {
					unset($size, $tmp4, $len);
					$size = null;
					if ($this->file->size > 4096) {
						$size = 4096;
					} else {
						$size = $this->file->size;
					}
					$len = 0;
					try {
						$len = $this->file->io->readBytes($buf, 0, $size);
					} catch (\Throwable $__hx__caught_e) {
						$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
						if ($__hx__real_e instanceof Eof) {
							$e = $__hx__real_e;
							break;
						} else  throw $__hx__caught_e;
					}
					$sock->output->writeFullBytes($buf, 0, $len);
					$tmp4 = $this->file;
					$tmp4->size = $tmp4->size - $len;
				}
				$sock->write("\x0D\x0A");
				$sock->write("--");
				$sock->write($boundary);
				$sock->write("--");
			}
			$this->readHttpResponse($api, $sock);
			$sock->close();
		} catch (\Throwable $__hx__caught_e) {
			$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
			$e1 = $__hx__real_e;
			try {
				$sock->close();
			} catch (\Throwable $__hx__caught_e) {
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				$e2 = $__hx__real_e;
							}
			($this->onError)(\Std::string($e1));
		}
	}


	/**
	 * @param string $data
	 * 
	 * @return void
	 */
	public function onData ($data)
	{
		if ($this->onData !== $this->__hx__default__onData) return call_user_func_array($this->onData, func_get_args());
			}
	protected $__hx__default__onData;


	/**
	 * @param string $msg
	 * 
	 * @return void
	 */
	public function onError ($msg)
	{
		if ($this->onError !== $this->__hx__default__onError) return call_user_func_array($this->onError, func_get_args());
			}
	protected $__hx__default__onError;


	/**
	 * @param int $status
	 * 
	 * @return void
	 */
	public function onStatus ($status)
	{
		if ($this->onStatus !== $this->__hx__default__onStatus) return call_user_func_array($this->onStatus, func_get_args());
			}
	protected $__hx__default__onStatus;


	/**
	 * @param \EReg $chunk_re
	 * @param Output $api
	 * @param Bytes $buf
	 * @param int $len
	 * 
	 * @return bool
	 */
	public function readChunk ($chunk_re, $api, $buf, $len) {
		if ($this->chunk_size === null) {
			if ($this->chunk_buf !== null) {
				$b = new BytesBuffer();
				($b->b .= $this->chunk_buf->b->s);
				$tmp = null;
				if ($len >= 0) {
					$tmp = $len > $buf->length;
				} else {
					$tmp = true;
				}
				if ($tmp) {
					throw new HxException(Error::OutsideBounds());
				} else {
					($b->b .= (new Container(substr($buf->b->s, 0, $len)))->s);
				}
				$buf = $b->getBytes();
				$len = $len + $this->chunk_buf->length;
				$this->chunk_buf = null;
			}
			if ($chunk_re->match($buf->toString())) {
				$p = $chunk_re->matchedPos();
				if ($p->len <= $len) {
					$cstr = $chunk_re->matched(1);
					$this->chunk_size = \Std::parseInt("0x" . ($cstr??'null'));
					if ($cstr === "0") {
						$this->chunk_size = null;
						$this->chunk_buf = null;
						return false;
					}
					$len = $len - $p->len;
					$pos = $p->len;
					$tmp1 = null;
					$tmp2 = null;
					$tmp3 = null;
					if ($pos >= 0) {
						$tmp3 = $len < 0;
					} else {
						$tmp3 = true;
					}
					if (!$tmp3) {
						$tmp2 = ($pos + $len) > $buf->length;
					} else {
						$tmp2 = true;
					}
					if ($tmp2) {
						throw new HxException(Error::OutsideBounds());
					} else {
						$tmp1 = new Bytes($len, new Container(substr($buf->b->s, $pos, $len)));
					}
					return $this->readChunk($chunk_re, $api, $tmp1, $len);
				}
			}
			if ($len > 10) {
				$this->onError("Invalid chunk");
				return false;
			}
			$tmp4 = null;
			$tmp5 = null;
			if ($len >= 0) {
				$tmp5 = $len > $buf->length;
			} else {
				$tmp5 = true;
			}
			if ($tmp5) {
				throw new HxException(Error::OutsideBounds());
			} else {
				$tmp4 = new Bytes($len, new Container(substr($buf->b->s, 0, $len)));
			}
			$this->chunk_buf = $tmp4;
			return true;
		}
		if ($this->chunk_size > $len) {
			$tmp6 = $this;
			$tmp6->chunk_size = $tmp6->chunk_size - $len;
			$api->writeBytes($buf, 0, $len);
			return true;
		}
		$end = $this->chunk_size + 2;
		if ($len >= $end) {
			if ($this->chunk_size > 0) {
				$api->writeBytes($buf, 0, $this->chunk_size);
			}
			$len = $len - $end;
			$this->chunk_size = null;
			if ($len === 0) {
				return true;
			}
			$tmp7 = null;
			$tmp8 = null;
			$tmp9 = null;
			if ($end >= 0) {
				$tmp9 = $len < 0;
			} else {
				$tmp9 = true;
			}
			if (!$tmp9) {
				$tmp8 = ($end + $len) > $buf->length;
			} else {
				$tmp8 = true;
			}
			if ($tmp8) {
				throw new HxException(Error::OutsideBounds());
			} else {
				$tmp7 = new Bytes($len, new Container(substr($buf->b->s, $end, $len)));
			}
			return $this->readChunk($chunk_re, $api, $tmp7, $len);
		}
		if ($this->chunk_size > 0) {
			$api->writeBytes($buf, 0, $this->chunk_size);
		}
		$tmp10 = $this;
		$tmp10->chunk_size = $tmp10->chunk_size - $len;
		return true;
	}


	/**
	 * @param Output $api
	 * @param Socket $sock
	 * 
	 * @return void
	 */
	public function readHttpResponse ($api, $sock) {
		$b = new BytesBuffer();
		$k = 4;
		$s = Bytes::alloc(4);
		$sock->setTimeout($this->cnxTimeout);
		while (true) {
			unset($tmp3, $c, $c3, $c1, $tmp, $tmp1, $tmp2, $c2, $p);
			$p = $sock->input->readBytes($s, 0, $k);
			while ($p !== $k) {
				$p = $p + $sock->input->readBytes($s, $p, $k - $p);
			}
			$tmp = null;
			if ($k >= 0) {
				$tmp = $k > $s->length;
			} else {
				$tmp = true;
			}
			if ($tmp) {
				throw new HxException(Error::OutsideBounds());
			} else {
				($b->b .= (new Container(substr($s->b->s, 0, $k)))->s);
			}
			switch ($k) {
				case 1:
					$c = ord($s->b->s[0]);
					if ($c === 10) {
						break 2;
					}
					if ($c === 13) {
						$k = 3;
					} else {
						$k = 4;
					}
					break;
				case 2:
					$c1 = ord($s->b->s[1]);
					if ($c1 === 10) {
						if (ord($s->b->s[0]) === 13) {
							break 2;
						}
						$k = 4;
					} else if ($c1 === 13) {
						$k = 3;
					} else {
						$k = 4;
					}
					break;
				case 3:
					$c2 = ord($s->b->s[2]);
					if ($c2 === 10) {
						if (ord($s->b->s[1]) !== 13) {
							$k = 4;
						} else if (ord($s->b->s[0]) !== 10) {
							$k = 2;
						} else {
							break 2;
						}
					} else if ($c2 === 13) {
						$tmp1 = null;
						if (ord($s->b->s[1]) === 10) {
							$tmp1 = ord($s->b->s[0]) !== 13;
						} else {
							$tmp1 = true;
						}
						if ($tmp1) {
							$k = 1;
						} else {
							$k = 3;
						}
					} else {
						$k = 4;
					}
					break;
				case 4:
					$c3 = ord($s->b->s[3]);
					if ($c3 === 10) {
						if (ord($s->b->s[2]) !== 13) {
							continue 2;
						} else {
							$tmp2 = null;
							if (ord($s->b->s[1]) === 10) {
								$tmp2 = ord($s->b->s[0]) !== 13;
							} else {
								$tmp2 = true;
							}
							if ($tmp2) {
								$k = 2;
							} else {
								break 2;
							}
						}
					} else if ($c3 === 13) {
						$tmp3 = null;
						if (ord($s->b->s[2]) === 10) {
							$tmp3 = ord($s->b->s[1]) !== 13;
						} else {
							$tmp3 = true;
						}
						if ($tmp3) {
							$k = 3;
						} else {
							$k = 1;
						}
					}
					break;
			}
		}
		$headers = HxString::split($b->getBytes()->toString(), "\x0D\x0A");
		$status = \Std::parseInt((HxString::split($headers->shift(), " ")->arr[1] ?? null));
		$tmp4 = null;
		if ($status !== 0) {
			$tmp4 = $status === null;
		} else {
			$tmp4 = true;
		}
		if ($tmp4) {
			throw new HxException("Response status error");
		}
		$headers->pop();
		$headers->pop();
		$this->responseHeaders = new StringMap();
		$size = null;
		$chunked = false;
		$_g = 0;
		while ($_g < $headers->length) {
			unset($hname, $hline, $hval, $a);
			$hline = ($headers->arr[$_g] ?? null);
			$_g = $_g + 1;
			$a = HxString::split($hline, ": ");
			$hname = $a->shift();
			$hval = null;
			if ($a->length === 1) {
				$hval = ($a->arr[0] ?? null);
			} else {
				$hval = $a->join(": ");
			}
			$hval = ltrim(rtrim($hval));
			$this->responseHeaders->data[$hname] = $hval;
			switch (HxString::toLowerCase($hname)) {
				case "content-length":
					$size = \Std::parseInt($hval);
					break;
				case "transfer-encoding":
					$chunked = HxString::toLowerCase($hval) === "chunked";
					break;
			}
		}

		$this->onStatus($status);
		$chunk_re = new \EReg("^([0-9A-Fa-f]+)[ ]*\x0D\x0A", "m");
		$this->chunk_size = null;
		$this->chunk_buf = null;
		$buf = Bytes::alloc(1024);
		if ($chunked) {
			try {
				while ($this->readChunk($chunk_re, $api, $buf, $sock->input->readBytes($buf, 0, 1024))) {
				}
			} catch (\Throwable $__hx__caught_e) {
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				if ($__hx__real_e instanceof Eof) {
					$e = $__hx__real_e;
					throw new HxException("Transfer aborted");
				} else  throw $__hx__caught_e;
			}
		} else if ($size === null) {
			if (!$this->noShutdown) {
				$sock->shutdown(false, true);
			}
			try {
				while (true) {
					$api->writeBytes($buf, 0, $sock->input->readBytes($buf, 0, 1024));
				}
			} catch (\Throwable $__hx__caught_e) {
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				if ($__hx__real_e instanceof Eof) {
					$e1 = $__hx__real_e;
									} else  throw $__hx__caught_e;
			}
		} else {
			try {
				while ($size > 0) {
					unset($len, $len1);
					$len = null;
					if ($size > 1024) {
						$len = 1024;
					} else {
						$len = $size;
					}
					$len1 = $sock->input->readBytes($buf, 0, $len);
					$api->writeBytes($buf, 0, $len1);
					$size = $size - $len1;
				}
			} catch (\Throwable $__hx__caught_e) {
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				if ($__hx__real_e instanceof Eof) {
					$e2 = $__hx__real_e;
					throw new HxException("Transfer aborted");
				} else  throw $__hx__caught_e;
			}
		}
		$tmp5 = null;
		if ($chunked) {
			if ($this->chunk_size === null) {
				$tmp5 = $this->chunk_buf !== null;
			} else {
				$tmp5 = true;
			}
		} else {
			$tmp5 = false;
		}
		if ($tmp5) {
			throw new HxException("Invalid chunk");
		}
		$tmp6 = null;
		if ($status >= 200) {
			$tmp6 = $status >= 400;
		} else {
			$tmp6 = true;
		}
		if ($tmp6) {
			throw new HxException("Http Error #" . ($status??'null'));
		}
		$api->close();
	}


	/**
	 * @param bool $post
	 * 
	 * @return void
	 */
	public function request ($post = null) {
		$_gthis = $this;
		$me = $this;
		$output = new BytesOutput();
		$old = $this->onError;
		$err = false;
		$this->onError = function ($e)  use (&$err, &$old, &$_gthis, &$output, &$me) {
			$me->responseData = $output->getBytes()->toString();
			$err = true;
			$_gthis->onError = $old;
			$_gthis->onError($e);
		};
		$this->customRequest($post, $output);
		if (!$err) {
			($me->onData)($me->responseData = $output->getBytes()->toString());
		}
	}


	/**
	 * @param string $param
	 * @param string $value
	 * 
	 * @return Http
	 */
	public function setParameter ($param, $value) {
		$this->params = \Lambda::filter($this->params, function ($p)  use (&$param) {
			return $p->param !== $param;
		});
		$this->params->push(new HxAnon([
			"param" => $param,
			"value" => $value,
		]));
		return $this;
	}
}


Boot::registerClass(Http::class, 'haxe.Http');
